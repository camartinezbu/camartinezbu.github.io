[ { "title": "Descubre cómo usar ChatGPT para ciencia de datos", "url": "/posts/descubre-como-usar-chatgpt-para-ciencia-de-datos/", "categories": "ChatGPT", "tags": "tutorial, trucos, tips, prompts", "date": "2023-05-18 18:50:00 -0500", "snippet": "Las herramientas basadas en modelos grandes de lenguaje (LLM – Large Language Models) han estado en los últimos meses en el foco de la conversación. No sólo por las capacidades que tienen para gene...", "content": "Las herramientas basadas en modelos grandes de lenguaje (LLM – Large Language Models) han estado en los últimos meses en el foco de la conversación. No sólo por las capacidades que tienen para generar textos de todo tipo de temas, sino también por la explosión en el número de modelos disponibles, tanto de empresas privadas como de iniciativas open source.No es sorpresa entonces que estos modelos pueden convertirse en una adición valiosa a tu caja de herramientas, ayudándote a resolver problemas, obtener ideas y optimizar tu proceso de análisis de datos. A continuación, quiero darte algunos consejos generales sobre cómo usar uno de estos modelos –ChatGPT– y proponerte algunos ejemplos específicos sobre cómo aprovecharlo al máximo en tu flujo de trabajo de ciencia de datos.Un aviso preliminarAunque ChatGPT puede ser una herramienta útil para obtener respuestas rápidas y explorar ideas, no olvides que no reemplaza las herramientas de búsqueda convencionales. Aunque ChatGPT puede ofrecerte información relevante y, a menudo, orientarte en la dirección correcta, sus respuestas pueden no ser tan precisas o completas como las que puedes obtener de otras fuentes.A la par de los consejos que te daré más adelante, no dependas exlusivamente de esta herramienta. Por el contrario, complementa su uso con la búsqueda de documentación, foros de discusión como StackOverflow o recursos especializados de ciencia de datos.Esto te permitirá tener una comprensión más sólida de los conceptos, técnicas y enfoques relacionados con tus proyectos, y a la vez, te da la posibilidad de sacarle aún más provecho a ChatGPT.Dicho lo anterior, ahora sí vamos a ver los consejos generales para usar esta herramienta.Consejos generalesSé claro y precisoAl interactuar con herramientas de chat como ChatGPT, es muy importante que le des instrucciones claras y específicas para obtener los resultados deseados. Para esto ayuda mucho que estés famililarizado con el tema de tu interés, porque conoces los conceptos y las palabras específicas de este tema y así podrás obtener respuestas de mayor utilidad. Por ejemplo, en vez de preguntar algo como “¿Cómo puedo mejorar mi modelo de clasificación?”, intenta ser más específico: “Dame tres técnicas efectivas para mejorar la precisión de mi modelo de clasificación en Python”.Da contexto sobre lo que estás haciendoCuando interactúes con ChatGPT, dale algunas oraciones de contexto sobre lo que vas a hacer. Intenta describir brevemente el problema que estás abordando, los datos que tienes disponibles y cualquier información adicional de contexto que consideres relevante. Esto ayudará a que la respuesta que obtengas esté más alineada con tu entrada. Por ejemplo, en vez de escribir “Explícame cómo hacer una regresión logística”, intenta “Necesito implementar una regresión logística en Python para resolver un problema de clasificación binaria de un conjunto de datos con la variable objetivo y 5 variables de explicación. Dame el código de Python y explícame cómo funciona”.Describe el formato de salida esperadoSi necesitas un formato particular para tu resultado o que este cumpla con alguna métrica puntual, indícalo en el prompt. Esto puede ser desde un número de palabras o párrafos deseados en la respuesta, hasta una lista explícita de cómo quieres tus resultados. Por ejemplo, en vez de preguntar: “¿Cómo lidiar con imágenes de distintos tamaños para un problema de clasificación de imágenes en deep learning?”, te sugiero intentar: “¿Cómo puedo lidiar con imágenes de distintos tamaños para un problema de clasificación de imágenes en deep learning? Por favor devuélveme la respuesta en el siguiente formato: - Acercamiento número N, - Título, - Descripción, - Pros, - Contras, - Implementación de código”.Juego de rol: Experto en ciencia de datosFinalmente, sobre todo cuando quieres obtener explicaciones de algún concepto o descripciones paso paso de algún código, suele servir que le indiques a ChatGPT que asuma el rol de algún experto en un tema específico y hacerle preguntas desde esa perspectiva. Por ejemplo, en vez de preguntarle: “¿Qué buenas prácticas existen para el análisis exploratorio de datos?”, intenta con “Eres un experto en análisis exploratorio de datos y necesito recomendaciones sobre las mejores prácticas y las visualizaciones más efectivas para identificar correlaciones en un conjunto de datos. ¿Qué me sugieres?”.Usos en Ciencia de DatosAhora vamos a explorar algunos casos de uso específicos de ChatGPT para tareas de ciencia de datos. El objetivo de esta sección es que te inspires para escribir prompts que te ayuden en tu día a día.Ejemplo 1.: Explicación de expresiones regularesLas expresiones regulares son herramientas muy poderosas a la hora de trabajar con textos, pero a simple vista, pueden ser complejas de leer. Especialmente si estás lidiando con expresiones muy largas o complejas.Podrías intentar darle un ejemplo de expresión regular y hacerle preguntas a ChatGPT como: “¿Podrías explicar cómo funciona esta expresión regular?” “¿Hay alguna forma más eficiante de escribir esta expresión regular para obtener el mismo resultado?” “¿Cuáles son los posibles casos de uso donde esta expresión regular podría fallar?”Ejemplo 2: Ayuda con pandas y manipulación de DataFramesSi estás trabajando con esta librería de Python y tienes dudas sobre cómo realizar una operación específica en un DataFrame, puedes usar ChatGPT para resolverlas. Recuerda los consejos que te di al inicio del post y dale contexto sobre la estructura de tu DataFrame y describe la tarea que quieres reallizar.Puedes preguntarle cosas como: “¿Puedes sugerirme cómo aplicar una función específica a una columna en mi DataFrame de Pandas?” “¿Cuál es la mejor forma de filtrar los datos en función de una condición en una columna específica de mi DataFrame?” “¿Puedes darme un ejemlo de cómo hacer un análisis exploratorio básico de mi DataFrame utilizando las funciones de pandas?”Ejemplo 3: Optimización de hiperparámetrosAl entrenar modelos de Machine Learning, es fundamental encontrar los hiperparámetros óptimos para mejorar el rendimiento de tus modelos. Puedes utilizar CHatGPT para obtener sugerencias y consejos sobre cómo ajustar los hiperparámetros de un modelo en el que estés trabajando. Sin embargo, no olvides consultar directamente la documentación y otros recursos.Para esta tarea, podrías preguntarle cosas como: “¿Podrías indicarme qué hiperparámetros puedo ajustar para este modelo de clasificación?” “¿Qué técnicas hay para evaluar diferentes combinaciones de hiperparámetros y cómo las implemento en código?” “¿Hay alguna forma de automatizar la búsqueda de hiperparámetros óptimos en Python?”Ejemplo 4: Extracción de datos mediante Web ScrappingPuedes utilizar ChatGPT para obtener ayuda con la implementación de Web Scraping o resolver dudas específicas que tengas con esta tarea.Algunas preguntas que podrías hacer son: “¿Podrías sugerirme algunas librerías de Python para realizar Web Scraping?” “¿Cómo puedo extraer datos de una tabla específica en una página web usando Web Scraping?” “¿Qué son los navegadores fantasma en el contexto de Web Scraping?”Ejemplo 5: Procesamiento de Lenguaje Natural (NLP)Si has trabajado con texto sabes que hay una gran cantidad de librerías que te permiten cumplir tareas de procesamiento de lenguaje natural. En esta aplicación, ChatGPT también puede ser útil para obtener consejos o para prototipar rápidamente.Puedes intentar preguntarle: “¿Existen librerías pre-entrenadas que pueden ayudame a clasificar automáticamente el sentimiento de un texto?” “¿Cuáles son las distintas aproximaciones paras tokenizar un texto en procesamiento de lenguaje natural? ¿sus pros y sus contras?” “Supón que tengo un DataFrame con oraciones en español. ¿Cómo se vería el código para hacer detección de entidades nombradas?”ConclusiónComo pudiste ver a lo largo de este post, escribir los prompts para modelos de lenguaje que interactúan a través de chat –como ChatGPT– es todo un arte. Si aplicas estos trucos, puedes mejorar la forma en la que estos modelos te ayudan a resolver problemas, prototipar ideas y optimizar tu flujo de trabajo. Sin embargo, no olvides complementar su uso con otras fuentes de información y motores de búsqueda para obtener respuestas más precisas.Espero que estos tips te sirvan para sacar el máximo provecho de ChatGPT en el campo de la ciencia de datos. Te invito a compartir estos tips con más personas y a experimentar con distintas formas de escribir tus prompts. ¡Éxitos en tu aprendizaje!" }, { "title": "Aprende a manejar rutas de archivo con pathlib", "url": "/posts/aprende-a-manejar-rutas-de-archivo-con-pathlib/", "categories": "Python", "tags": "tutorial, carpetas, archivos", "date": "2023-05-03 13:43:00 -0500", "snippet": "Si ya has trabajando en scripts o cuadernos de jupyter para algún proyecto de ciencia de datos, probablemente hayas experimentado problemas para manejar las rutas de archivos. En este post te quier...", "content": "Si ya has trabajando en scripts o cuadernos de jupyter para algún proyecto de ciencia de datos, probablemente hayas experimentado problemas para manejar las rutas de archivos. En este post te quiero explicar el funcionamiento de pathlib, una librería que te facilitará la interacción con archivos en tu computador y que seguro te será útil en tus proyectos de programación.Pathlibpathlib es una librería de Python que te proporciona una forma amigable y consistente para trabajar con rutas de archivo en tu computador. Esto lo hace a través de una aproximación orientada a objetos, por lo que si ya tienes familiaridad con este paradigma, no tendrás muchos problemas en incorporarla en tu flujo normal de trabajo.¿Cómo funciona?Las rutas de archivo en pathlib se representan a través de un objeto de clase Path. Este objeto funciona como un string común y corriente, pero con métodos que lo hacen más útil para trabajar con carpetas y archivos en tu computador.Para crear un objeto de clase Path, tienes que pasar un string con la ruta de archivo a la función del mismo nombre así:from pathlib import Pathmi_ruta = Path(\"carpeta/archivo.txt\")Esto creara un objeto llamado mi_ruta que representa un archivo llamado archivo.txt al interior de la carpeta con un nombre muy creativo: carpeta. En Windows, la sintaxis de las rutas de archivo usa barras invertidas (\\) en lugar de las barras diagonales (/). Esto puede causar algunos problemas si Python piensa que estás tratando de “escapar” el siguiente caracter y no queriendo usar la barra invertida como tal. No obstante, pathlib se encarga automáticamente de estos errores, entonces no te tienes que preocupar por hacer ajustes manuales al string de la ruta de archivo.Enlazar rutas de archivoTambién puedes crear rutas de archivo más complejhas al concatenar varias partes usando el operador /, tal como lo harías en una ruta de archivos ordinaria en MacOS o Linux. Por ejemplo, puedes hacer algo de este estilo:carpeta_madre = Path(\"Documentos\")carpeta_hija = carpeta_madre / \"Proyectos\" / \"Proyecto_1\"archivo_final = carpeta_hija / \"documento.docx\"En el ejemplo, carpeta_madre es una ruta que representa la carpeta Documentos. Luego la variable carpeta_hija crea un objeto tipo Path que representa una carpeta Proyecto_1 que se encuentra al interior de Proyectos, a su vez dentro de Documentos. Finalmente, archivo_final describe una ruta con un archivo documento.docx al interior de la carpeta Proyecto_1.Atributos de los objetos PathLos objetos de clase Path tienen muchos atributos que te pueden ser de utilidad. Acá te dejo algunos de los más usados: Atributos Descripción .name El último componente de la ruta .parent El directorio padre de la ruta .stem El último componente de la ruta sin la extensión .suffix La extensión de la última componente de la ruta .drive La letra de la unidad del disco en sistemas Windows (p.e. C:\\) .root La parte inicial de la ruta que denota la raíz del sistema de archivos (/ en Linux o C:\\ en Windows) Funciones útilespathlib también contiene varias functiones que puedes usar para interactuar más directamente con archivos y directorios. En esta tabla te resumo algunos de ellos. Funciones Descripción mkdir() Crea un nuevo directorio en la ruta especificada exists() Verifica si la ruta especificada existe is_dir() Verifica si la ruta especificada es un directorio o carpeta is_file() Verifica si la ruta especificada es un archivo glob() Devuelve un iterador que produce todas las rutas que coinciden con un patrón glob rglob() Devuelve un iterador que produce todas las rutas que coinciden con un patrón glob de manera recursiva Los patrones glob son cadenas de texto que se usan para buscar archivos y directorios en la shell de Unix. Puedes encontrar más información sobre ellos acá.Ahora que conoces los conceptos básicos, veamos un ejemplo práctico de cómo podrías usar pathlib en Python.Ejemplo prácticoSupongamos que tienes un archivo llamado datos.csv en una carpeta llamada Proyecto en el escritorio de tu computador. Podrías ir manualmente a la ubicación del archivo con tu explorador de archivos y copiar la ruta. O también podrías hacerlo con lo que acabas de aprender sobre pathlib.Primero, crea la ruta completa de de este archivo. En este ejemplo voy a usar la función Path.home(), que devuelve un objeto Path que representa el directorio de inicio del usuario actual. En Windows esto debería ser algo como C:\\Users\\usuario, en Linux /home/usuario y en MacOS /Users/usuario. Arrancar en esta ruta puede ayudar a ubicar más fácilmente los archivos o carpetas.from pathlib import Pathruta_completa = Path.home() / \"Escritorio\" / \"proyecto\" / \"datos.csv\"Ahora que tienes la ruta completa de tu archivo, puedes abrirlo y trabajar con él desde otras librerías de acuerdo con tu necesidad. pathlib funciona con varias librerías populares de Python como pandas, scikit-learn o torch.También puedes aprovechar la funcionalidad de Pathlib de una forma más programática. Por ejemplo, podrías usar código para verificar si un archivo o carpeta existen antes de trabajar con ellos:from pathlib import Pathruta_completa = Path.home() / \"Escritorio\" / \"proyecto\" / \"datos.csv\"if ruta_completa.exists(): with open(ruta_completa, \"r\") as datos: # Ejecuta algún cálculo con los datos print(\"Archivo leido con éxito.\")else: print(\"El archivo no existe.\")En este caso, ruta_completa.exists() revisa si el archivo datos.csv existe en el lugar que le indicamos. Si el archivo existe, podemos abrirlo y hacer alguna operación dentro el bloque de código with. Si no, se imprime el mensaje \"El archivo no existe.\" en la consola.ConclusiónComo puedes ver, pathlib es una librería muy útil para trabajar con archivos y directorios en Python. Los objetos de clase Path tienen varios atributos y funciones que te van a facilitar la vida a la hora de crear, eliminar y renombrar archivos y carpetas. Así que es un activo muy útil para tu caja de herramientas de ciencia de datos.¿Qué otros usos se te ocurren para trabajar con pathlib?Si te pareció útil este artículo, te invito a compartirlo con más personas. ¡Éxitos en tu aprendizaje!" }, { "title": "¿Cómo funcionan los decoradores en Python?", "url": "/posts/como-funcionan-los-decoradores-en-python/", "categories": "Python", "tags": "decoradores, tutorial, concepto", "date": "2023-04-07 13:19:00 -0500", "snippet": "Los decoradores en Python son una característica poderosa y útil que te permiten modificar o envolver el comportamiento de una función sin modificar su código original. Sin embargo, si vienes de ot...", "content": "Los decoradores en Python son una característica poderosa y útil que te permiten modificar o envolver el comportamiento de una función sin modificar su código original. Sin embargo, si vienes de otros lenguajes o eres principiante en programación, puede que su funcionamiento sea un poco enredado.En este artículo quiero explicarte cómo funcionan y darte algunos ejemplos básicos para que puedas involucrarlos en tu flujo de trabajo ordinario en Python.Los decoradoresEn Python, un decorador es una función que toma otra función como argumento y devuelve una nueva función que generalmente agrega alguna funcionalidad al comportamiento original. Los decoradores se aplican utilizando el símbolo @ seguido del nombre de la función decoradora justo encima de la función que deseas decorar.Cuando llamas a la función decorada, en realidad estás llamando a la función devuelta por el decorador, que puede realizar alguna tarea adicional antes o después de la ejecución de la función original.La estructura generalPara implementar un decorador en Python, puedes seguir una estructura básica como la que se presenta a continuación:def decorador(func): # Definir una nueva función que \"envuelve\" la función original def wrapper(*args, **kwargs): # Haz algo antes de llamar la función original resultado = func(*args, **kwargs) # Haz algo después de llamar la función original return result # Devuelve la nueva función return wrapperVeamos paso a paso cómo funciona el código detrás del decorador. Primero, creas una función llamada decorador que toma como argumento a otra función llamada func. Al interior de decorador, creas otra función que se llama wrapper, que como su nombre lo indica, tiene como objetivo “envolver” la función func.Hay que notar dos cosas sobre esta función. Por un lado, que los argumentos de la función wrapper son *args y **kwargs. Esto es porque no sabes los argumentos específicos de todas las funciones a las que le puedes aplicar el decorador. *args y **kwargs garantizan que el resultado del decorador va a usar esos mismos argumentos.Por otro lado, que dentro de la función wrapper se definen las acciones que vas a implementar antes o después de la función original. En el ejemplo anterior, aparecen como dos mensajes en pseudocódigo antes y después de resultado. ¡Este es lugar donde los decoradores hacen su magia!Como puedes ver, el decorador devuelve la función wrapper. Es decir, la función original (func) que incluye los cambios dictados por el decorador.Finalmente, para aplicar el decorador a otra función, simplemente debes escribir un arroba (@) seguido del nombre del decorador. Inmediatamente debajo, debes crear a la función a la que le quieres aplicar el decorador. Algo así:@decoradordef mi_funcion(): # Tu función especifica return # El resultado que quieres devolver con tu funciónMedir el tiempo de ejecuciónUno de los ejemplos clásicos sobre los decoradores es la creación de uno que ejecute una función particular y te permita medir cuánto se demora en ejecutarse.Veamos cómo funcionaría siguiendo la estructura anterior. El pseudocódigo asociado se vería algo así:# Crear la función decoradora, que tome como argumento otra función # Definir la función que envuelve (wrapper) la función original # Calcular el tiempo de inicio de ejecución # Ejecutar la función original # Calcular el tiempo del fin de ejecucuón # Imprimir el tiempo de ejecución en consola # Devolver el resultado (en este caso la función original) # Devolver la función wrapperComo puedes ver, dado que lo que queremos hacer es calcular el tiempo de ejecución, vamos a guardar dos momentos en el tiempo e imprimiremos la diferencia entre el tiempo de inicio y el de finalización. No en todos los casos necesitas hacer algo antes y después de la función original. Debes ajustar el decorador de acuerdo con tu uso específico.Si esta estructura está clara, pasemos a cómo se vería incluyendo el código de Python:import time# Crear la función decoradora, que tome como argumento otra funcióndef tiempo_ejecucion(func): # Definir la función que envuelve (wrapper) la función original def wrapper(*args, **kwargs): # Calcular el tiempo de inicio de ejecución tiempo_inicio = time.time() # Ejecutar la función original resultado = func(*args, **kwargs) # Calcular el tiempo del fin de ejecucuón tiempo_fin = time.time() # Imprimir el tiempo de ejecución en consola print(f'{func.__name__} se demoró {tiempo_fin - tiempo_inicio:.2f} segundos en su ejecución.') # Devolver el resultado (en este caso la función original) return resultado # Devolver la función wrapper return wrapperVarias precisiones en el código anterior. Es necesario cargar el módulo time para poder calcular el momento en que arranca y termina la ejecución de tu función. Como lo vimos anteriormente, en la definición de wrapper, así como en la llamada de func dentro de su alcance, usamos los argumentos *args y **kwargs. No olvides incluirlos para que el decorador funcione correctamente. En el mensaje que se imprime en consola se está usando un f-string, una manera más concisa de incluir los valores de variables en strings. Como puedes ver, el mensaje incluye el nonbre de la función a la que le aplicas el decorador, así como el tiempo de ejecución en segundos, redondeado a 2 dígitos.El decorador en acciónSupón que quieres calcular cuánto se demora tu código en ejecutar una función que crea una list comprehension que calcula los cuadrados de los números del 0 al n, donde n es un argumento que le pasas a la función. Es decir, algo como esto:def calcular_cuadrados(numero): return [i**2 for i in range(numero + 1)]calcular_cuadrados(9)# La salida en consola sería:# [0, 1, 4, 9, 16, 25, 36, 49, 64, 81] Como te puedes imaginar, en este ejemplo sencillo el tiempo de ejcución va a redondearse a 0 segundos. No obstante, el decorador funcionará igual para funciones que se demoran más en ejecutarse.Si quieres aplicar el decorador que creamos anteriormente, tienes que llamarlo con el caracter @ antes de la definición de la función. Algo así:@tiempo_ejecuciondef calcular_cuadrados(numero): return [i**2 for i in range(numero + 1)]calcular_cuadrados(9)# La salida en consola sería:# calcular_cuadrados se demoró 0.00 segundos en su ejecución.# [0, 1, 4, 9, 16, 25, 36, 49, 64, 81]ConclusiónEspero que con este post te quede un poco más claro cómo es el funcionamiento de los decoradores en Python. Para que lo puedas aplicar, te dejo la tarea de pensar en qué luegares de tu flujo de trabajo podrías utilizar los decoradores.Piensa especialmente en tareas que tienes que hacer de manera reiterativa para múltiples funciones. Puede ser el cálculo de alguna estadística de resumen para una base de datos o la aplicación de algún tema o título en tus gráficos.En los próximos días te compartiré varios ejemplos que pueden serte de utilidad, con la explicación paso a paso de cómo los construí.Espero que te haya gustado este artículo. Si te pareció útil, te invito a compartirlo con más peronas. ¡Éxitos en tu aprendizaje!" }, { "title": "Google Colab vs Deepnote", "url": "/posts/google-colab-vs-deepnote/", "categories": "Jupyter", "tags": "colab, deepnote, jupyter, herramientas", "date": "2023-03-10 12:30:00 -0500", "snippet": "Sin duda alguna, los cuadernos de Jupyter son una de las herramientas más útiles en el arsenal de un científico de datos. Ayudan en el prototipado rápido de soluciones, así como en la documentación...", "content": "Sin duda alguna, los cuadernos de Jupyter son una de las herramientas más útiles en el arsenal de un científico de datos. Ayudan en el prototipado rápido de soluciones, así como en la documentación y reproducibilidad de modelos, gracias a que permiten trabajar simultáneamente con celdas de código y celdas de texto usando Markdown.En este post quiero contarte sobre dos herramientas que me gusta usar para trabajar con cuadernos de Jupyter: Google Colab y Deepnote. Además de permitir la ejecución de tus cuadernos en servidores remotos, tienen varias funcionalidad específicas que puedes encontrar de utilidad.IntroducciónGoogle Colab, es un servicio de Google que te permite ejecutar cuadernos de Jupyter en sus servidores. Dado que está inmerso en la suite de productos de Google, puedes hacer interactuar con gran facilidad el cuaderno con archivos que tengas en la nube de Google Drive. Arrancar a trabajar con Colab es muy fácil, dado que te provee un ambiente de trabajo que tiene instalados Python 3.8, así como muchas librerías que se usan a menudo en el campo de la ciencia de datos, como Plotly, Numpy, Pandas, Matplotlib o Tensorflow.Por su parte, Deepnote es un producto que consiste en cuadernos de Jupyter que te permiten trabajar de forma colaborativa. Los cuadernos de Deepnote permiten la conexión con fuentes de datos como Google BigQuery, Snowflakle, PostgreSQL, Amazon RedShift, entre otros. Además de varias versiones de Python, los cuadernos de Deepnote también incluyen ambientes con varias versiones de R. Técnicamente, Google Colab también tiene la opción de trabajar con ambientes de R. No obstante, la interfaz de Colab no permite seleccionar este ambiente; es necesario entrar a través de un enlace como este https://colab.research.google.com/notebook#create=true&amp;language=r. E incluso en ese escenario, Deepnote ofrece mayor facilidad para cambiar entre versiones de Python y R.Funciones y característicasGoogle Colab te ofrece la experiencia más parecida a los cuadernos de Jupyter estándar. Te permite crear celdas de texto y código, en los que puedes incluir imágenes, videos, enlaces a otros cuadernos, etc. Asimismo, incluye todas las funciones de magics de jupyter. Estas son líneas de código que puedes escribir el inicio de la celda para cambiar la manera como se ejecuta. Algo así como decoradores para el contenido de la celda. Por ejemplo, si escribes %%timeit al inicio de una celda en Colab, la salida te mostrará el tiempo de ejecución del código que está en ella.La cosa se pone más interesante con Deepnote. Además de las celdas de texto y código, Deepnote incluye celdas de SQL, de Gráficos y de Entrada. Veamos qué hace cada una de ellas. SQL: Para proyectos en los que tienes enlazada una base de datos SQL, Deepnote te permite interactuar directamente con queries desde el cuaderno y trabajar con el resultado como si fuera un DataFrame de Pandas. Por lo pronto, esta función sirve únicamente para los cuadernos con Python.Fuente: Documentación de Deepnote Gráficos: Las celdas de gráficos permiten crear visualizaciones de datos de DataFrames de pandas sin usar una línea de código. En vez de tener que buscar la documentación de matplotlib o seaborn, Deepnote te ofrece una interfaz más parecida a los programas de inteligencia de negocios, en la que puedes seleccionar el tipo de gráfico, las variables y los atributos que quieres mapear.Fuente: Documentación de Deepnote Entrada: Con Deepnote también se pueden hacer tableros de visualización básicos. Estas celdas contienen entradas de texto, selección, sliders y fechas que interactúan con variables del ambiente de trabajo para volverlos interactivos. ¡Puedes prototipar tableros antes de pasarlos a Shiny o Dash!Fuente: Documentación de DeepnoteComparación de preciosTanto Google Colab como Deepnote incluyen planes gratuitos y pagos. La diferencia está en el enfoque con el que cada servicio diferencia los niveles de pago: el precio de Google Colab depende en mayor medida de la capacidad de computación que requieres y el de Deepnote, de las funcionalidades de colaboración que requieras.Planes gratuitosEl plan gratuito de Google Colab es el plan por defecto cuando abres un cuaderno en esta plataforma. Este te permite ejecutar el código en tus cuadernos, tanto en CPU como GPU y TPU de Google, sujeto a dispinibilidad. Esto significa que en momentos de alta demanda te puedes encontrar con que no puedes usar tarjetas gráficas. No obstante, puedes crear un número ilimitado de cuadernos de Colab con tu cuenta.En Deepnote, el plan gratuito incluye la creación de hasta 5 proyectos en los que puedes invitar a colaborar a máximo 3 personas. Además, en este nivel tienes acceso ilimitado CPU con 5GB de RAM, pero no a tarjetas de video. Este uso está sujeto a políticas de fair use, por lo que Deepnote puede apagar el cuaderno si detecta algún tipo de actividad sospechosa.Planes pagosGoogle Colab ofrece 2 suscripciones y un plan Pay as you go para acceder a computadores más poderosos y funcionalidades extra en la ejecución de los cuadernos: Colab Pro: La suscripción mensual cuesta USD $9.99 (o COP $43.165 al momento de escribir este post accediendo desde Colombia). Obtienes 100 unidades de cómputo al mes, así como acceso a máquinas con más memoria (hasta 32GB) y una terminal en la máquina virtual. Colab Pro+: Esta opción cuesta USD $49.99 (o COP $215.996). Incluye todo lo que viene en Colab Pro, con 400 unidades de cómputo adicionales, acceso a máquinas con aún más memoria (hasta 52GB) y permite la ejecucuón de los cuadernos por hasta 24 horas sin que tengas que tener la ventana del navegador abierta. Pay as you go: En este caso pagas solamente por las unidades de computación que necesites. Y los precios están acorde con lo que te ofrecen las dos suscripciones anteriores: 100 unidades te cuestan USD $9.99 y 500 te cuestan USD $49.99. Las unidades de computación permiten la ejecución del cuaderno en las máquinas virtuales de Google Cloud. Son una especie de medida de tu acceso a sus servidores. Para las suscripciones mensuales, estas unidades de computación expiran luego de 90 días desde la compra.Por su parte, Deepnote ofrece dos suscripciones diseñadas para equipos y empresas, con funciones avanzadas para la colaboración: Deepnote Team: Este plan cuesta USD $39 por editor por mes. Contempla la creación de un número ilimitado de proyectos en los que pueden colaborar cualquier número de editores. Además, te da acceso a máquinas virtuales de hasta 16GB de RAM –y de hasta 128GB bajo el modelo pay as you go– e integraciones con servicios como Snowflake, SQL Server, BigQuery, Redshift, entre otras; que no se encuentran disponibles en la versión gratuita. Además, permite la ejecución de cuadernos por hasta 24 horas sin que tengas que interactuar con el navegador. Deepnote Enterprise: No hay un precio fijo para este plan, sino que tienes que cotizar con el equipo de ventas de Deepnote. Además de las opciones incluidas en el plan anterior, este incluye un historial ilimitado de versiones de los cuadernos, soporte dedicado y la opción de construir máquinas personalizadas según tu necesidad. Incluso es posible la instalación de una nube privada on-premise en tu organización.ConclusiónTanto Google Colab como Deepnote son herramientas muy interesantes para ejecutar cuadernos de Jupyter en servidores remotos. Y afortunadamente, cuentan con versiones gratuitas para que pruebes sus funcionalidades y te des cuenta cuál se adecúa mejor a tu flujo de trabajo. Google Colab puede ser más útil si eres un entusiasta de la ciencia de datos y quieres poner en marcha proyectos de pequeña escala. Mientras que Deepnote puede ser una solución más adecuada si el tamaño de tu operación es mucho más grande y necesitas acceder a soporte especializado.¿Conoces otra herramienta que permite la ejecución de cuadernos de Jupyter en la Nube? Cuéntame en los comentarios o en mis redes sociales." }, { "title": "¿Cómo trabajar con fechas en Pandas?", "url": "/posts/como-trabajar-con-fechas-en-pandas/", "categories": "Python", "tags": "fechas, datetimes, lubridate, r, pandas", "date": "2022-12-21 16:50:00 -0500", "snippet": "El trabajo con fechas tiene numerosas complejidades, entre las que se cuentan el formato de escritura de las fechas, las zonas horarias y las diferentes formas de hablar de duraciones de tiempo.En ...", "content": "El trabajo con fechas tiene numerosas complejidades, entre las que se cuentan el formato de escritura de las fechas, las zonas horarias y las diferentes formas de hablar de duraciones de tiempo.En este post quiero explicarte cómo leer, manipular y hacer aritmética con fechas usando pandas. Si buscas un tutorial para el módulo datetime, dirígete a este enlace. Si te interesa aprender a trabajar con fechas en R, te invito a leer esta publicación.pandasPandas es una de las librerías más usadas para trabajar con datos tabulares en Python. Esta incluye un gran número de funciones para leer, limpiar, modificar, hacer análisis descriptivo y exportar tablas; entre ellas, algunas diseñadas para optimizar tu trabajo con fechas y horas.Veamos los tipos de objetos relacionados con fechas con los que te vas a encontrar en pandas.Tipos de objetosPandas te permite capturar 4 conceptos relacionados con el tiempo: Momentos puntuales. Periodos: Una duración de tiempo que consiste en un punto de partida y una frecuencia. Diferencias de tiempo absolutas: que no tienen en cuenta la aritmética de los calendarios. Por ejemplo, años bisiestos. Diferencias de tiempo relativas: que si tienen en cuenta la aritmética de los calendarios.Cada uno de estos conceptos está asociado a una función específica que crea objetos de distinta clase, dependiendo de si el argumento que se le pasa es un escalar, un array o un objeto de Python (Series o DataFrames). La siguiente tabla describe estas relaciones: Concepto Función asociada Clase escalar Clase Array Clase Pandas Momento puntual to_datetime() Timestamp DatetimeIndex datetime64[ns] o datetime64[ns, tz] Periodos Period() Period PeriodIndex period[freq] Diferencias absolutas to_timedelta() Timedelta TimedeltaIndex timedelta64[ns] Diferencias relativas DateOffset() DateOffset None None Lectura de fechasPor lo pronto, veamos cómo funciona la lectura de fechas desde strings para los momentos puntuales, es decir, los objetos que están asociados con la función to_datetime(). En el siguiente bloque de código voy a crear un string, una lista y una serie de pandas con texto en formato ISO 8601:import pandas as pdmi_string = \"2022-11-06\"mi_array = [\"2022-11-06\", \"2022-12-06\", \"2023-01-06\"]mi_serie = pd.Series([\"2022-11-06\", \"2022-12-06\", \"2023-01-06\"]) El formato ISO 8601 es un estándar internacional para escribir fechas y horas, que elimina ambigüedades entre las distintas maneras de escribir fechas. En general, este estándar consiste en escribir primero las unidades más grandes (p.e. años) y luego las unidades más pequeñas (p.e. meses o días). Los componentes de la fecha se separan con un guión (-) y los componentes de la hora con dos puntos (:).Los siguientes son los resultados de aplicar la función to_datetime() a los 3 tipos de objetos. Como te darás cuenta, estos corresponden a la tabla que mencioné con anterioridad:# Stringpd.to_datetime(mi_string)# Timestamp('2022-11-06 00:00:00')# Arraypd.todatetime(mi_array)# DatetimeIndex(['2022-11-06', '2022-12-06', '2023-01-06'], dtype='datetime64[ns]', freq=None)# Seriepd.to_datetime(mi_serie)# 0 2022-11-06# 1 2022-12-06# 2 2023-01-06# dtype: datetime64[ns]Ahora bien, ¿qué sucede cuando el formato de los strings en los que tienes tus fechas no coincide con el estándar ISO 8601? En estos casos, debes proveer la estructura de la fecha en el argumento format. Esta estructura se escribe con un string especial compuesto por caracteres que representan cada uno de los elementos. Estos caracteres son los mismos que funcionan con el paquete datetime de Python base: Medida de tiempo Ejemplo Caracter asociado Año con siglo \"1987\" \"%Y\" Año sin siglo \"87\" \"%y\" Mes en número \"02\" \"%m\" Mes en palabra larga \"Febrero\" \"%B\" Mes en palabra corta \"Feb\" \"%b\" Día del mes \"04\" \"%d\" Hora (formato 24 horas) \"19\" \"%H\" Hora (formato 12 horas) \"07\" \"%h\" Identificador de mañana o tarde \"PM\" \"%p\" Minuto \"30\" \"%M\" Segundo \"00\" \"%S\" Supón que tienes un string en tu DataFrame que contiene una columna con las fechas en las que algún registro se actualizó, con el siguiente formato \"Updated on 09 Dec 2022 at 13:30:05\". Al ejecutar la función to_datetime() sin ningún argumento adicional, Python te devolverá un error porque pandas no sabe cómo interpretar ese string:pd.to_datetime(\"Updated on 09 December 2022 at 13:30:05\")# ParserError: Unknown string format: Updated on 09 Dec 2022 at 13:30:05Ahora intentemos con el argumento format. En este caso, puedes ver que el string contiene el número del día (%d), el nombre largo del mes (%bB), el año incluyendo los dígitos del siglo (%Y), la hora en formato 24 horas (%H), los minutos (%M) y los segundos (%S). Con esta información puedes construir el string que iría en format así:pd.to_datetime(\"Updated on 09 December 2022 at 13:30:05\", format = \"Updated on %d %B %Y at %H:%M:%S\")# Timestamp('2022-12-09 13:30:05')Sin embargo, el código anterior sólo funciona para fechas que estén escritas en inglés, dado que contiene el nombre del mes en ese idioma. Si quisieras leer directamente el string \"Actualizado el 09 de Diciembre de 2022 a las 13:30:05\", pandas te devolvería un error porque no reconoce Diciembre como el nombre de un mes:pd.to_datetime(\"Actualizado el 09 de Diciembre de 2022 a las 13:30:05\", \t\t\t format = \"Actualizado el %d de %B de %Y a las %H:%M:%S\")# ValueError: time data 'Actualizado el 09 de Diciembre de 2022 a las 13:30:05' does not match format 'Actualizado el %d de %B de %Y a las %H:%M:%S' (match)Para corregir este error, tienes que definir el idioma en el que va a correr tu ambiente de Python usando la función setlocale del módulo locale. Como queremos que Python lea los nombres de los meses en español tenemos que usar el locale \"es_ES\" así:import locale# Cambiar el idioma a españollocale.setlocale(locale.LC_TIME, \"es_ES\")# Leer la fechapd.to_datetime(\"Actualizado el 09 de Diciembre de 2022 a las 13:30:05\", \t\t\t format = \"Actualizado el %d de %B de %Y a las %H:%M:%S\")# Timestamp('2022-12-09 13:30:05')Unidades de tiempoPuedes acceder a una gran cantidad de elementos de los objetos Timestamp y DatetimeIndex llamando los atributos que se describen en la siguiente tabla. Si quieres más información, puedes ver la lista completa de atributos en el siguiente enlace. Atributo Descripción year Año month Mes day Día del mes hour Hora minute Minuto Second Segundo date Fecha sin información de zona horaria time Hora sin información de zona horaria timetz Hora incluyendo información de zona horaria dayofyear Día del año dayofweek Día de la semana (0 es lunes y 6 es domingo) daysinmonth Número de días del mes actual Veamos un ejemplo. Supón que tienes un objeto Timestamp como el que se presenta a continuación. Puedes extraer los elementos fácilmente así:mi_ejemplo = pd.to_datetime('2022-12-09 14:20:35')# Imprimir los componentes de la fechaprint(\"Año:\", mi_ejemplo.year)print(\"Mes:\", mi_ejemplo.month)print(\"Día:\", mi_ejemplo.day)print(\"Hora:\", mi_ejemplo.hour)print(\"Minuto:\", mi_ejemplo.minute)print(\"Segundo:\", mi_ejemplo.second)print(\"Día del año:\", mi_ejemplo.dayofyear)# Año: 2022# Mes: 12# Día: 9# Hora: 14# Minuto: 20# Segundo: 35# Día del año: 343Te habrás dado cuenta que en los objetos que mencioné hace falta la Serie de datetime64[ns]. Esto es porque la forma de acceder a los componentes de la fecha es ligeramente diferente. En vez de llamar directamente el nombre del atributo como en la tabla, lo que tienes que hacer es poner primero el atributo dt. Es decir, si quieres extraer la hora de una Serie de fechas, deberías escribir algo como:mi_serie = pd.to_datetime(pd.Series(['2022-12-09 14:20:35',\t\t\t\t\t\t\t\t\t'2022-12-15 15:30:14',\t\t\t\t\t\t\t\t\t'2023-01-04 09:55:22']))# Extraer la horaprint(mi_serie.dt.hour)# 0 14# 1 15# 2 9# dtype: int64Zonas horariasDetrás de cámaras, pandas usa las librerías pytz y dateutil para manejar zonas horarias. Por defecto, los objetos que creas no tienen información de zona horaria. Pero esto se puede modificar fácilmente con las mismas lógicas de pytz. Veamos las operaciones más comunes que tendrás que realizar: Definir la zona horaria de la fecha: Si comienzas con un objeto que no tiene información de zona horaria, puedes definirla con el con el método tz_localize().mi_fecha_hora = pd.to_datetime('2022-12-09 14:20:35')# Timestamp('2022-12-09 14:20:35')# Definir la zona horaria de Bogotámi_fecha_hora.tz_localize(\"America/Bogota\")# Timestamp('2022-12-09 14:20:35-0500', tz='America/Bogota') Es muy importante que guardes este resultado en un variable –o sobreescribas la existente–. De lo contrario, no se guardarán los cambios a la zona horaria. Cambiar de una zona horaria a otra: Para esto, puedes usar el método tz_convert(), escribiendo como argumento la zona horaria que quieres como resultado.# Definir un objeto en hora de Bogotámi_fecha_hora_bog = pd.to_datetime('2022-12-09 14:20:35').tz_localize(\"America/Bogota\")# Timestamp('2022-12-09 14:20:35-0500', tz='America/Bogota')# Transformarlo a hora de Madridmi_fecha_hora_mad = mi_fecha_hora_bog.tz_convert(\"Europe/Madrid\")# Timestamp('2022-12-09 20:20:35+0100', tz='Europe/Madrid')# Transformarlo a hora de Tokyomi_fecha_hora_tok = mi_fecha_hora_bog.tz_convert(\"Asia/Tokyo\")# Timestamp('2022-12-10 04:20:35+0900', tz='Asia/Tokyo') Forzar una zona horaria sin cambiar la hora original: Primero tienes que eliminar la información de zona horaria de tu objeto de interés usando tz_localize(None) y luego, incluyes la zona horaria que desees usando de nuevo tz_localize().# Definir un objeto en hora de Bogotámi_fecha_hora_bog = pd.to_datetime('2022-12-09 14:20:35').tz_localize(\"America/Bogota\")# Timestamp('2022-12-09 14:20:35-0500', tz='America/Bogota')# Forzar el objeto a hora de Madridmi_fecha_hora_mad2 = mi_fecha_hora_bog.tz_localize(None).tz_localize(\"Europe/Madrid\")# Timestamp('2022-12-09 14:20:35+0100', tz='Europe/Madrid')# Forzar el objeto a la hora de Tokyomi_fecha_hora_tok2 = mi_fecha_hora_bog.tz_localize(None).tz_localize(\"Asia/Tokyo\")# Timestamp('2022-12-09 14:20:35+0900', tz='Asia/Tokyo')PeriodosEs momento de hablar de los tipos de objetos que quedaron pendientes. Los periodos representan duraciones de tiempo con una fecha específica de inicio. Esto se traduce en una diferencia sutil frente a los objetos tipo Timestamp: mientras que los Timestamp representan un momento específico en el tiempo, los objetos tipo Period describen una ventana de tiempo que comienza en un momento específico. En otras palabras, en vez de referirnos a un punto arbitrario en el tiempo como el 10 de diciembre de 2022, hablamos del día, semana o mes que comienzan a partir del 10 de diciembre de 2022.De manera similar a los momentos puntuales, podemos crear objetos distintos dependiendo de si partimos de un escalar, un vector o un objeto de pandas. Dado su propósito, la función Period contiene un argumento llamado freq, que define el tamaño de la ventana de tiempo que queremos definir. Algunas de las periodicidades más comunes son: Caracter Descripción D Día calendario B Día hábil W Semana M Mes Q Trimestre Y Año H Hora T Minuto S Segundo Puedes consultar el resto de duraciones en el siguiente linkA modo de ejemplo, puedes crear objetos de la familia de Period así:import pandas as pdmi_string = \"2022-11-06\"mi_array = [\"2022-11-06\", \"2022-12-06\", \"2023-01-06\"]mi_serie = pd.Series([\"2022-11-06\", \"2022-12-06\", \"2023-01-06\"])# Period con duración de 2 días.pd.Period(mi_string, freq=\"2D\")# Period('2022-11-06', '2D')# PeriodIndex con duración de 1 semana.pd.PeriodIndex(mi_array, freq=\"W\")# PeriodIndex(['2022-10-31/2022-11-06', '2022-12-05/2022-12-11',# '2023-01-02/2023-01-08'],# dtype='period[W-SUN]', freq='W-SUN')# period[freq] con duración de 1 semanapd.to_datetime(mi_serie).dt.to_period(\"W\")# 0 2022-10-31/2022-11-06# 1 2022-12-05/2022-12-11# 2 2023-01-02/2023-01-08dtype: period[W-SUN] Nota que para crear una serie de objetos tipo period[freq] necesitas partir de un array que ya sea un Timestamp o un DatetimeIndex. Por tal motivo, antes de usar el método to_period(), fue necesario convertir la serie con la función pd.to_datetime().TimedeltasLos objetos tipo Timedelta funcionan muy similar a los timedelta del módulo datetime. En resumen, describen un intervalo de tiempo exacto, medido en unidades como días, horas, minutos, segundos etc. Puedes crear estos objetos con la función Timedelta() y ajustar su duración con parámetros comp days, hours, etc. Aquí puedes ver un ejemplo de cómo usarlos para hacer aritmética con fechas.# Crear un Timedeltami_timedelta = pd.Timedelta(days=30)# Timedelta('30 days 00:00:00')# Usar un timedelta para conseguir una nueva fechami_timestamp = pd.to_datetime(\"2022-12-21\")# Timestamp('2022-12-21 00:00:00')mi_timestamp + mi_timedelta# Timestamp('2023-01-20 00:00:00') Dada su construcción, no puedes usar Timedelta para representar duraciones de tiempo variables como las que usamos en nuestro lenguaje cotidiano. Para eso están los objetos tipoDateOffset, que verás a continuación.DateOffsetsPor su parte, los objetos de tipo DateOffset también se usan para describir intervalos de tiempo; pero en vez de hacerlo en términos de unidades exactas de tiempo, lo hacen siguiendo las reglas del calendario. Por ejemplo, un DateOffset con una duración de 1 mes, puede tener duraciones reales de 29, 29, 30 o 31 días dependiendo del mes y el año desde el que se calcule.Como argumentos de la función DateOffset() puedes incluir duraciones como años (years), meses (months), semanas(weeks), días(days), entre otros. Encontrarás los demás argumentos en este enlace. A continuación verás un ejemplo de trabajo con objetos DateOffset.# Crear un DateOffsetmi_dateoffset = pd.DateOffset(months=1)# Crear una fecha de inicio:mi_timestamp = pd.to_datetime(\"2023-01-21\")# Timestamp('2023-01-21 00:00:00')# Calcular la fecha más un mesmi_timestamp2 = mi_timestamp + mi_dateoffset# Timestamp('2023-02-21 00:00:00')# ¿Cuántos días de diferencia tienen las dos fechas?(mi_timestamp + mi_dateoffset) - mi_timestamp# Timedelta('31 days 00:00:00') Como puedes ver, al calcular la diferencia entre dos fechas obtienes un objeto tipo Timedelta. Intenta cambiar los argumentos de DateOffset() y calcula la diferencia entre las fechas para que veas la variabilidad en su duración.Conclusiones¡Felicidades, ya sabes usar pandas para trabajar con fechas! Con las herramientas que aprendiste en este blog podrás desarrollar un gran número de tareas relacionadas con fechas. Como recursos adicionales, te dejo los enlaces a un par de tutoriales que escribí para que aprendas a hacer tareas similares en R y en Python.Te invito a dejar un comentario abajo si tienes algún truco sobre el manejo de datetime y, si te pareció útil este post, a compartirlo en tus redes sociales." }, { "title": "¿Cómo trabajar con fechas en Python?", "url": "/posts/como-trabajar-con-fechas-en-python/", "categories": "Python", "tags": "fechas, datetimes, lubridate, r", "date": "2022-12-19 10:20:00 -0500", "snippet": "En una publicación anterior te hablé sobre las dificultades que te puedes encontrar cuando trabajes con fechas en tus proyectos de ciencia de datos. Para que puedas resolverlas, estoy escribiendo u...", "content": "En una publicación anterior te hablé sobre las dificultades que te puedes encontrar cuando trabajes con fechas en tus proyectos de ciencia de datos. Para que puedas resolverlas, estoy escribiendo una serie de turoriales para que aprendas a trabajar con algunas de las herramientas más poderosas.Al final de este post, sabrás como leer, manipular y hacer aritmética con fechas usando datetime. Si buscas un tutorial de pandas, te lo dejo en este enlace. Si te interesa aprender a trabajar con fechas en R, te invito a leer esta publicación.datetimedatetime es un módulo que viene en la instalación base de Python y que contiene todas las herramientas necesitarás para trabajar con fechas y horas.Antes de entrar en las tareas que puedes hacer con este módulo, veamos algunos de los objetos con los que vas a trabajar. Estos dependerán de qué tanta información contiene tu campo de fecha.Tipos de objetosSi únicamente tienes información sobre el año, mes y día, vas a utilizar el tipo datetime.date. Veamos un ejemplo sencillo creando una fecha con la función date(), que recibe como argumentos el año, el mes y el día:from datetime import datemi_fecha = date(2022,12,10)# datetime.date(2022, 12, 10)type(mi_fecha)# datetime.dateSi además tienes información del momento preciso –horas, minutos y segundos–, vas a trabajar con datetime.datetime. Podemos crear un objeto de este tipo con la función datetime(), que recibe como argumentos el año, mes, día, hora, minuto y segundo:from datetime import datetimemi_fecha_hora = datetime(2022,12,10,19,30,0)# datetime.datetime(1022, 12, 10, 19, 30)type(mi_fecha_hora)# datetime.datetime Más adelante verás otro tipo de objeto de datetime: timedelta, que se encarga de las diferencias entre dos fechas.Lectura de fechasEn la vida real, te vas a encontrar con fechas que están en formato str. Veamos cómo las puedes leer usando el módulo datetime. Empecemos con el caso en el que tienes una fecha escrita en formato ISO 8601: \"2022-12-10\". En el estándar ISO 8601 se escriben las fechas de la mayor unidad a la menor unidad, separando año, día y mes con un guión (-); y hora, mes y año con dos puntos (:). Esto evita la ambigüedad a la hora de interpretar a qué unidad pertenece cada número.Para leerla como datetime.date, puedes ejecutar el siguiente código:from datetime import datemi_fecha = date.fromisoformat(\"2022-12-10\")# datetime.date(2022, 12, 10) Desde la versión de Python 3.11 en adelante, puedes aplicar esta función incluso cuando no se separan las fechas con guión. Por ejemplo: from datetime import datemi_fecha1 = date.fromisoformat(\"2022/12/10\")# datetime.date(2022, 12, 10)mi_fecha2 = date.fromisoformat(\"20221210\")# datetime.date(2022, 12, 10)mi_fecha3 = date.fromisoformat(\"2022:12:10\")# datetime.date(2022, 12, 10) Esto mismo aplica para los datetime. Lo único que tenemos que cambiar es el tipo de objeto desde el que corremos el método:from datetime import datetimemi_fecha_hora = datetime.fromisoformat(\"2022-12-10 19:30:00\")# datetime.datetime(2022, 12, 10, 19, 30)¿Qué pasa cuando el str de la fecha no está en formato ISO 8601? Aquí deberás usar el método strptime(), que recibe dos argumentos: el texto que contiene la fecha y un texto especial que le dice al método cómo leer esa fecha.Este texto especial funciona con caracteres que describen cada elemento de la fecha, los más comunes se describen en la siguiente tabla: Medida de tiempo Ejemplo Caracter asociado Año con siglo \"1987\" \"%Y\" Año sin siglo \"87\" \"%y\" Mes en número \"02\" \"%m\" Mes en palabra larga \"Febrero\" \"%B\" Mes en palabra corta \"Feb\" \"%b\" Día del mes \"04\" \"%d\" Hora (formato 24 horas) \"19\" \"%H\" Hora (formato 12 horas) \"07\" \"%h\" Identificador de mañana o tarde \"PM\" \"%p\" Minuto \"30\" \"%M\" Segundo \"00\" \"%S\" Entonces, supón que tienes un str de texto así: \"Created on Dec 10/2022 at 19:30\". Con los caracteres de la tabla anterior, puedes leerlo así:from datetime import datetimemi_fecha_texto = datetime.strptime(\"Created on Dec 10/2022 at 19:30\", \"Created on %b %d/%Y at %H:%M\")# datetime.datetime(2022, 12, 10, 19, 30)Ahora bien, esto no funciona para nombres de meses que estén escritos en otro idioma distinto a inglés. Para ello, debes configurar el idioma de tu ambiente ejecutando la función locale.set_locale(), con el segundo argumento ajustado al código del idioma y el país. Para español puedes usar \"es_ES\":import locale# Cambiar el idioma a españollocale.setlocale(locale.LC_TIME, \"es_ES\")# Leer la fechami_fecha_texto_es = datetime.strptime(\"Creado en Dic 10/2022 a las 19:30\", \"Creado en %b %d/%Y a las %H:%M\")# datetime.datetime(2022, 12, 10, 19, 30)Unidades de tiempoLeer las fechas es apenas el principio. Usualmente tienes que extraer elementos puntuales de las fechas para hacer comparaciones o filtrar bases de datos. Esto lo puedes hacer usando distintos atributos y métodos que tienen los objetos date y datetime.Para los objetos date, puedes extraer el año, el mes y el día con los atributos year, month y date, respectivamente. Además, puedes extraer el día de la semana con el método isoweekday():mi_fecha = date(2022,12,10)# datetime.date(2022, 12, 10)mi_fecha.year# 2022mi_fecha.month# 12mi_fecha.day# 10mi_fecha.isoweekday()# 6Para el caso de objetos tipo datetime, también puedes acceder a la hora, minuto, segundo con los atributos hour, minute y second:mi_fecha_hora = datetime(2022,12,10,19,30,0)# datetime.datetime(2022, 12, 10, 19, 30)mi_fecha_hora.hour# 19mi_fecha_hora.minute# 30mi_fecha_hora.second# 0 Las funciones que incluye el módulo datetime son relativamente limitadas. También puedes consultar los objetos de clase datetime64 y timedelta64 de Numpy para conocer lo que pueden hacer. Adicionalmente, en los próximos días voy a subir un tutorial para el manejo de fechas con pandas.Zonas horariasEs muy importante que sepas lidiar con zonas horarias, especialmente porque te puedes encontrar con datasets cuyo alcance vaya más allá de la jurisdicción de un país o se desarrollen en una zona geográfica muy amplia. Para las operaciones que verás más abajo, necesitas instalar la librería pytz, ya que esta contiene información útil sobre zonas horarias y algunos métodos útiles para modificar los objetos datetime. Definir la zona horaria de la fecha: Si estás partiendo de un datetime que no tiene información de zona horaria –datetime.tzinfo es None–, necesitas crear un objeto pytz.timezone con un str que indique la zona horaria de tu interés. Posteriormente, ejecutas el método localize(), usando como argumento el datetime que quieres convertir:import pytzmi_fecha_hora = datetime(2022,12,10,19,30,0)# datetime.datetime(1022, 12, 10, 19, 30)# Hora de Bogotámi_fecha_hora_bog = pytz.timezone(\"America/Bogota\").localize(mi_fecha_hora)# datetime.datetime(2022, 12, 10, 19, 30, tzinfo=&lt;DstTzInfo 'America/Bogota' -05-1 day, 19:00:00 STD&gt;)# Hora de Madridmi_fecha_hora_mad = pytz.timezone(\"Europe/Madrid\").localize(mi_fecha_hora)# datetime.datetime(2022, 12, 10, 19, 30, tzinfo=&lt;DstTzInfo 'Europe/Madrid' CET+1:00:00 STD&gt;)# Hora de Tokyomi_fecha_hora_mad = pytz.timezone(\"Asia/Tokyo\").localize(mi_fecha_hora)#datetime.datetime(2022, 12, 10, 19, 30, tzinfo=&lt;DstTzInfo 'Asia/Tokyo' JST+9:00:00 STD&gt;) Es muy importante que guardes este resultado en un variable –o sobreescribas la existente–. De lo contrario, no se guardarán los cambios a la zona horaria. Cambiar una zona horaria a otra: Para cambiar tu hora a una hora local de otra ubicación, puedes usar el método astimezone() del objeto datetime, usando como argumento la zona horaria de pytz:import pytz# Hora de Bogotá en hora local de Madridmi_fecha_hora_mad2 = mi_fecha_hora_bog.astimezone(pytz.timezone(\"Europa/Madrid\"))# datetime.datetime(2022, 12, 11, 1, 30, tzinfo=&lt;DstTzInfo 'Europe/Madrid' CET+1:00:00 STD&gt;)# Hora de Bogotá en hora local de Tokyomi_fecha_hora_tok2 = mi_fecha_hora_bog.astimezone(pytz.timezone(\"Europa/Madrid\"))# datetime.datetime(2022, 12, 11, 9, 30, tzinfo=&lt;DstTzInfo 'Asia/Tokyo' JST+9:00:00 STD&gt;) Forzar una zona horaria sin cambiar la hora original: Si tu datetime ya tiene una zona horaria asociada, lo primero que tienes que hacer es eliminar el atributo tzinfo, usando el método replace(), para luego seguir los pasos para un datetime sin zona horaria:import pytzmi_fecha_hora_bog# datetime.datetime(2022, 12, 10, 19, 30, tzinfo=&lt;DstTzInfo 'America/Bogota' -05-1 day, 19:00:00 STD&gt;)# Extraer la fecha y hora sin la zona horariami_fecha_hora_sin_tz = mi_fecha_hora_bog.replace(tzinfo=None)# datetime.datetime(2022, 12, 10, 19, 30)# Forzar la hora a hora de Madridmi_fecha_hora_mad3 = pytz.timezone(\"Europe/Madrid\").localize(mi_fecha_hora_sin_tz)# datetime.datetime(2022, 12, 10, 19, 30, tzinfo=&lt;DstTzInfo 'Europe/Madrid' CET+1:00:00 STD&gt;)# Forzar la hora a hora de Tokyomi_fecha_hora_tok3 = pytz.timezone(\"Asia/Tokyo\").localize(mi_fecha_hora_sin_tz)#datetime.datetime(2022, 12, 10, 19, 30, tzinfo=&lt;DstTzInfo 'Asia/Tokyo' JST+9:00:00 STD&gt;)TimedeltasLos objetos de tipo timedelta representan una diferencia entre dos fechas o tiempos, en unidades fijas de días, segundos y microsegundos. Esto significa que el timedelta no tiene en cuenta características del uso ordinario de las fechas como horarios de verano, el número de días de los meses o años bisiestos.from datetime import timedelta# Crear un timedeltami_delta = timedelta(days = 30)# datetime.timedelta(days=30)# Aplicar un timedelta a una fechami_fecha_hora = datetime(2022,12,10,19,30,0)# datetime.datetime(2022, 12, 10, 19, 30)mi_fecha_hora + mi_delta# datetime.datetime(2023, 1, 9, 19, 30)A la función también se le pueden pasar argumentos como milisegundos, minutos, horas y semanas, pero estos siempre se van a convertir en términos de días, segundos y microsegundos.Conclusiones¡Felicidades, ya sabes usar datetime! Con las herramientas que aprendiste en este blog podrás desarrollar un gran número de tareas relacionadas con fechas. Como recurso adicional, te dejo estos posts donde aprenderás a trabajar con fechas en R y en pandasTe invito a dejar un comentario abajo si tienes algún truco sobre el manejo de datetime y, si te pareció útil este post, a compartirlo en tus redes sociales." }, { "title": "¿Cómo trabajar con fechas en R?", "url": "/posts/como-trabajar-con-fechas-en-r/", "categories": "R", "tags": "fechas, datetimes, lubridate, r", "date": "2022-12-17 10:10:00 -0500", "snippet": "Saber trabajar correctamente con fechas es una herramienta fundamental para cualquier científico de datos, ya que es muy común encontrarse con columnas de este tipo en los datasets. Sin embargo, co...", "content": "Saber trabajar correctamente con fechas es una herramienta fundamental para cualquier científico de datos, ya que es muy común encontrarse con columnas de este tipo en los datasets. Sin embargo, como lo explico en esta publicación, no es algo trivial dadas algunas complejidades propias de las fechas.Al final de este post, sabrás como leer, manipular y hacer aritmética con fechas usando el paquete lubridate. Si te interesa aprender a trabajar con fechas en Python, te invito s leer los posts correspondientes a datetime y pandas.Tipos de datos primitivos en RAntes de empezar, es útil hacer un repaso de los tipos de datos que utiliza R base para trabajar con fechas. Lubridate crea un tipo de objeto nuevo, sino que te ofrece un conjunto de funciones para trabajar con ellos.Dependiendo de qué tanta información contiene tu campo de fecha, vas a trabajar con distintos tipos de objetos en R. Cuando sólo se tiene año, mes y día, R trabaja con el tipo de dato Date. Internamente, este consiste en un conteo de los días que han pasado desde el primero de enero de 1970.Puedes leer una fecha desde un character usando la función as.Date(). A modo de ejemplo:mi_fecha &lt;- as.Date(\"2022-12-10\")Ahora bien, si además tienes información del momento preciso –horas, minutos y segundos–, R va a trabajar con el tipo de dato POSIXct. Este consiste en un conteo de segundos desde el 1 de enero de 1970 a media noche. R no cuenta con una clase nativa que guarde únicamente horas, minutos y segundos. El paquete hms incluye la clase hms que habilita esta funcionalidad.Para leer una fecha de este estilo desde un character, puedes usar la función as.POSIXct() así:mi_fecha_hora &lt;- as.POSIXct(\"2022-12-10 19:30:00\") El formato en el que están escritas la fechas anteriores se conoce como ISO 8601. En este estándar se escriben las fechas de la mayor unidad a la menor unidad: Año antes que mes, mes antes que día, y así sucesivamente. De esta manera, se elimina la ambigüedad a la hora de interpretar a qué unidad pertenece cada número.LubridateLubridate es un paquete que te ofrece funciones que aplican sobre fechas en formato Date y POSIXct, que te facilitarán mucho tu trabajo. Adicionalmente, este paquete funciona muy bien con otros paquetes del tidyverse, por lo que lo puedes incorporar sin mayores problemas en tu código existente. Veamos algunas tareas que puedes hacer con lubridate.Lectura de fechasEl primer paso es leer un character que contiene una fecha en tu dataset. Si bien podrías hacerlo como lo mostré en un ejemplo anterior con las funciones as.Date() y as.POSIXct(), no siempre tendrás la fortuna de que las fechas estén en el formato ISO 8601.Por esta razón, lubridate te ofrece una familia de funciones que puedes usar para leer configuraciones comunes. Estas se basan en una letra para denotar cada unidad: “y”” para año, “m” para mes, “d” para día, “h” para hora, “m” para minuto y “s” para segundo. Es cierto que la “m” se repite en esta asignación. Sin embargo, esto no es un problema porque las funciones de lubridate separan el componente de fecha y el de hora con un guión bajo (_), como lo verás más adelante.Con esta lógica, se construyen funciones como ymd(), que te permite leer un character en el que el orden es Año-Mes-Día, sin importar el caracter que las separe. También funciones como mdy(), que espera un orden Mes-Día-Año, dym(), que espera Día-Año-Mes, y demás combinaciones de esas letras.A modo de ejemplo, al ejecutar las siguientes líneas de código tendrás exactamente el mismo objeto Date:library(lubridate)# Estas líneas devuelven la misma fecha: mi_fecha1 &lt;- ymd(\"2022-12-10\")mi_fecha2 &lt;- mdy(\"12/10/2022\")mi_fecha3 &lt;- dym(\"10:2022:12\")#&gt; \"2022-12-10\"Lo mismo sucede si añadimos datos de hora. Con las mismas letras se construyen funciones como ymd_hms(), que puede crear un objeto POSIXct a partir de un texto en orden Año-Mes-Día-Hora-Minuto-Segundo. Ya te podrás imaginar qué hacen funciones como mdy_hm() o dmy_h().Veamos qué resulta de ejecutar las siguientes funciones:library(lubridate)# Año-Mes-Día Hora-Minuto-Segundomi_fecha_hora1 &lt;- ymd_hms(\"2022-12-10 19:30:00\")#&gt; \"2022-12-10 19:30:00 UTC\"# Mes-Día-Año Hora-Minutomi_fecha_hora2 &lt;- mdy_hm(\"12/10/2022_19_30\")#&gt; \"2022-12-10 19:30:00 UTC\"# Día-Mes-Año Horami_fecha_hora3 &lt;- dmy_h(\"10:12:2022 19\")#&gt; \"2022-12-10 19:00:00 UTC\" También puedes cargar una fecha que aparezca como una combinación entre año y trimestre (p.e. \"2022:4\") usando la función yq().Unidades de tiempo¡Perfecto! Ya sabes cargar una fecha con lubridate. Ahora vas a aprender a extraer los elementos individuales de las fechas. Puedes acceder al año, mes, día, hora, minuto, segundo y más unidades de tiempo de tu objeto tipo Date o POSIXct, con las siguientes funciones:mi_fecha_hora &lt;- ymd_hms(\"2022-12-10 19:30:00\")# Añoyear(mi_fecha_hora) #&gt; 2022# Mesmonth(mi_fecha_hora) #&gt; 12# Díaday(mi_fecha_hora) #&gt; 10# Horahour(mi_fecha_hora) #&gt; 19# Minutominute(mi_fecha_hora)#&gt; 30 # Segundosecond(mi_fecha_hora) #&gt; 0# Trimestequarter(mi_fecha_hora) #&gt; 4# Semestresemester(mi_fecha_hora) #&gt; 2# Día de la semanawday(mi_fecha_hora, week_start = 1) #&gt; 6 En la función wday() es necesario poner el argumento week_start = 1 para que el lunes sea el primer día de la semana –y no el domingo, que es la función por defecto–. Esto hace que el valor que devuelve la función sea 6, dado que la fecha del ejemplo es un sábado. Si no lo haces, la función te devuelve el 7, ya que es el séptimo día de la semana si comienzas a contar desde el domingo.Hasta el momento, todos los campos de fecha que hemos revisado se devuelven como un integer. Sin embargo, también puedes hacer que la función month() devuelva el nombre del mes o wday() el nombre del día. Hay dos argumentos que intervienen en esta operación: el primero es label, que le indica a lubridate que debe imprimir un nombre y no un número, y el segundo es abbr, que define si quieres una representación larga o corta del nombre. Veamos.mi_fecha_hora &lt;- ymd_hms(\"2022-12-10 19:30:00\")# Nombre del mes sin abreviarmonth(mi_fecha_hora, label = TRUE, abbr = FALSE)#&gt; diciembre# Nombre del mes sin abreviarmonth(mi_fecha_hora, label = TRUE, abbr = TRUE)#&gt; dic Dependiendo de la configuración de idioma de tu computador, así como el sistema operativo que estés usando, puede que la función te devuelva el nombre del mes o del día en otro idioma. Para forzar un idioma de salida de la función, debes usar el argumento locale con un código de idioma y país. Para español puedes usar \"es_ES\".Zonas horariasOtro aspecto que debes saber manejar son las zonas horarias. Si estás trabajando con un set de datos que escapa a la jurisdicción de un país o que se desarrolla en una zona geográfica muy amplia, puedes encontrarte con fechas que están en distintos husos horarios. Hay 3 operaciones que vas a aprender: Definir la zona horaria de la fecha apenas la lees: Para hacerlo, simplemente debes agregar a cualquiera de las funciones vistas con anterioridad el argumento tz, con el código de la zona horaria de tu interés. Puedes consultar una lista de zonas horarias en este enlace.# Hora de Bogotámi_fecha_hora_bog &lt;- ymd_hms(\"2022-12-10 19:30:00\", tz = \"America/Bogota\")#&gt; \"2022-12-10 19:30:00 -05\"# Hora de Madridmi_fecha_hora_mad &lt;- ymd_hms(\"2022-12-10 19:30:00\", tz = \"Europe/Madrid\")#&gt; \"2022-12-10 19:30:00 CET\"# Hora de Tokyomi_fecha_hora_tok &lt;- ymd_hms(\"2022-12-10 19:30:00\", tz = \"Asia/Tokyo\")#&gt; \"2022-12-10 19:30:00 JST\" Por defecto, la zona horaria que se incluye en las fechas es UTC, elTiempo Universal Coordinado, que para efectos prácticos corresponde al tiempo del Meridiano de Greenwich. Cambiar una fecha de una zona horaria a otra: La función with_tz() permite cambiar una fecha de una zona horaria a otra en horario local. Esta función tiene dos argumentos principales: la fecha que queremos convertir y la zona horaria objetivo.# Hora de Bogotámi_fecha_hora_bog &lt;- ymd_hms(\"2022-12-10 19:30:00\", tz = \"America/Bogota\")#&gt; \"2022-12-10 19:30:00 -05\"# Hora de Bogotá en hora local de Madridmi_fecha_hora_mad2 &lt;- with_tz(mi_fecha_hora_bog, tz = \"Europe/Madrid\")#&gt; \"2022-12-11 01:30:00 CET\"# Hora de Bogotá en hora local de Tokyomi_fecha_hora_tok2 &lt;- with_tz(mi_fecha_hora_bog, tz = \"Asia/Tokyo\")#&gt; \"2022-12-11 09:30:00 JST\" Forzar una zona horaria sin cambiar la hora original: La función force_tz() permite cambiar la zona horaria de una fecha sin hacer la transformación anterior. Es decir, conservando intacta la hora.# Hora de Bogotámi_fecha_hora_bog &lt;- ymd_hms(\"2022-12-10 19:30:00\", tz = \"America/Bogota\")#&gt; \"2022-12-10 19:30:00 -05\"# Forzar la hora de Bogotá a hora de Madridmi_fecha_hora_mad3 &lt;- force_tz(mi_fecha_hora_bog, tz = \"Europe/Madrid\")#&gt; \"2022-12-10 19:30:00 CET\"# Forzar la hora de Bogotá a hora de Tokyomi_fecha_hora_tok3 &lt;- force_tz(mi_fecha_hora_bog, tz = \"Asia/Tokyo\")#&gt; \"2022-12-10 19:30:00 JST\"PeriodosLos periodos corresponden a los espacios de tiempo en unidades que usamos en el día a día, como años, meses, semanas o días. Es decir que incorporan características como horarios de verano, número de días de los meses o años bisiestos. Estos objetos te pueden servir para ubicar fechas que ocurren con cierta periodicidad específica en términos humanos.La siguiente tabla resume las funciones que puedes usar para crear periodos. No incluyo una columna de unidad porque, por construcción, los periodos no tienen siempre la misma duración en segundos. Periodo Función de lubridate Años years() Meses months() Semanas weeks() Días days() Horas hours() Minutos minutes() Segundos seconds() Milisegundos milliseconds() Microsegundos microseconds() Puedes obtener el mismo día del próximo año de la siguiente manera:mi_fecha_hora &lt;- ymd_hms(\"2022-12-10 19:30:00\")#&gt; \"2022-12-10 19:30:00 UTC\"# Misma fecha en el próximo añomi_fecha_hora + years(1)#&gt; \"2023-12-10 19:30:00 UTC\" DuracionesPor el contrario, las duraciones corresponden a espacios de tiempo exactos, medidos en segundos. A las duraciones no les interesan las reglas de los calendarios –horarios de verano, número de días de los meses, años bisiestos–, por lo que pueden ser muy útiles cuando quieres automatizar procesos en tus scripts o guardar información sobre experimentos.La siguiente tabla resume las unidades de tiempo que puedes manejar y a cuántos segundos equivalen: Duración # segundos Función de lubridate Años 31536000 dyears() Meses 2629800 dmonths() Semanas 604800 dweeks() Días 86400 ddays() Horas 3600 dhours() Minutos 60 dminutes() Segundos 1 dseconds() Milisegundos 0.001 dmilliseconds() Microsegundos 0.000001 dmicroseconds() A modo de ejemplo, para obtener una fecha más una duración de un año puedes escribir lo siguiente:mi_fecha_hora &lt;- ymd_hms(\"2022-12-10 19:30:00\")#&gt; \"2022-12-10 19:30:00 UTC\"# Fecha + Duración de 1 año (31536000 segundos)mi_fecha_hora + dyears(1)#&gt; \"2023-12-11 01:30:00 UTC\" IntervalosLos intervalos representan la diferencia de tiempo entre dos fechas y se pueden dividir entre periodos y duraciones para obtener su longitud en estas medidas. Estos se pueden calcular de dos maneras: llamando la función interval() con las dos fechas o escribiendo los caracteres %--% entre las dos fechas.Por ejemplo, usando los casos anteriores podemos escribir algo como:mi_fecha_inicio &lt;- ymd_hms(\"2022-12-10 19:30:00\")#&gt; \"2022-12-10 19:30:00 UTC\"mi_fecha_final &lt;- ymd_hms(\"2023-02-10 19:30:00\")#&gt; \"2023-02-10 19:30:00 UTC\"# Intervalo calculado con la función interval()mi_intervalo &lt;- interval(mi_fecha_inicio, mi_fecha_final)#&gt; 2022-12-10 19:30:00 UTC--2023-02-10 19:30:00 UTC# Intervalo calculado con %--%mi_intervalo2 &lt;- mi_fecha_inicio %--% mi_fecha_final#&gt; 2022-12-10 19:30:00 UTC--2023-02-10 19:30:00 UTC# Periodos del intervalomi_intervalo / months(1)#&gt; 2# Duraciones del intervalomi_intervalo / dmonths(1)#&gt; 2.036961Integración con el TidyverseComo lo mencioné anteriormente, lubridate está diseñado desde el comienzo para trabajar muy bien con las funciones del tidyverse. Esto significa que puedes ejecutar todas las funciones que viste con anterioridad con funciones como group_by(), mutate(), filter(), sort(), summarise(), etc.Por ejemplo si tienes una columna con fechas POSIXct que registre algún evento, podrías agrupar por el año y el trimestre con un código así:dataframe |&gt;\tgroup_by(anio = year(fecha), trimestre = quarter(fecha)) |&gt;\tsummarise(promedio = mean(variable_interes))¡Inténtalo! Verás que es muy fácil extrapolar todos los conceptos que vimos a tu flujo de trabajo ordinario.Conclusión¡Felicidades, ya sabes usar lubridate! Con las herramientas que aprendiste en este blog podrás desarrollar un gran número de tareas relacionadas con fechas. Como recursos adicionales, te dejo este cheat sheet elaborado por Posit, que te ayudará a recordar las funciones de este paquete cuando las necesites. Cuando se publiquen, pondré los enlaces de los posts sobre cómo trabajar con fechas en datetime y pandas en Python.Te invito a dejar un comentario abajo si tienes algún truco sobre el manejo de lubridate y, si te pareció útil este post, a compartirlo en tus redes sociales." }, { "title": "3 razones que dificultan el trabajo con fechas", "url": "/posts/3-razones-que-dificultan-el-trabajo-con-fechas/", "categories": "Conceptos", "tags": "fechas, datetimes, lubridate, r, python", "date": "2022-12-15 18:10:00 -0500", "snippet": "Una de las tareas más habituales en el trabajo de un científico de datos tiene que ver con el manejo de fechas. Asumiendo que tus datos ya están ordenados, los campos que describen fechas te van a ...", "content": "Una de las tareas más habituales en el trabajo de un científico de datos tiene que ver con el manejo de fechas. Asumiendo que tus datos ya están ordenados, los campos que describen fechas te van a permitir hacer agrupaciones de tus observaciones de acuerdo con periodos de tiempo específicos, encontrar patrones útiles para la toma de decisiones y ayudarte a diseñar visualizaciones de datos llamativas y fáciles de entender.Sin embargo, el trabajo con fechas no es tan evidente. En este post quiero hablar sobre por qué es complejo trabajar con fechas y al final encontrarás el enlace para aprender a usar lubridate en R, así como datetime y pandas en Python.1. Formato de escrituraDependiendo del lugar de origen de tu dataset o la organización que lo elabora, te vas a encontrar con que las fechas tienen una gran cantidad de formatos distintos. Para ilustrar este punto, veamos las formas en las que podrías escribir el 5 de octubre de 2022.Empecemos con representaciones de esa fecha que usan únicamente números. Con esta restricción, podríamos modificar el orden en el que aparecen los elementos de la fecha, así como los caracteres que los separan. Frente al orden, podríamos escribir esta fecha así: Año/Mes/Día: 2022/10/05 Día/Mes/Año: 05/10/2022 Mes/Día/Año: 10/05/2022Por otra parte, no es necesario que escribas el año de la fecha con cuatro dígitos. Los siguientes ejemplos usan una notación más corta: Día/Mes/Año corto: 05/10/22 Mes/Día/Año corto: 10/05/22Con respecto a los caracteres, también podrías representar esa fecha sin usar el “/”, reemplazándolo por caracteres como: 2022-10-05 2022_10_05 2022 10 05 20221005Si permitimos que los elementos de la fecha estén escritos como palabras, el universo de posibilidades se amplia aún más. Acá puedes ver algunas formas alternativas en las que podrías escribir la fecha del ejemplo: 5 Oct 2022 5 de Octubre de 2022 Octubre 5 2022 A este último caso le podemos añadir una complejidad adicional. Dado que las fechas están escritas en lenguaje natural, también te puedes encontrar con fechas en otros idiomas: 5th October 5, 2022, Octobre 5 2022, u Outubro 5, 2022.2. Zonas horariasTodo lo anterior asume que las fechas con las que estás trabajando tienen la misma zona horaria, pero este no siempre es el caso. Imagina que tienes un dataset con las salidas y llegadas de los vuelos de una aerolínea, expresadas en hora local. En este caso, dos vuelos que tengan 2022/03/01 05:43:00 AM en la columna de hora de llegada pueden hacer referencia a dos momentos completamente distintos.Esto sin contar las modificaciones especiales a la hora, como el Horario de Verano –o Daylight Savings Time–, que adelanta la hora del reloj durante los meses más calientes del año y que se utiliza en partes de Estados Unidos, Canadá, varios países de Europa, Chile, Paraguay, entre otros.Mapa de lugares que emplean el horario de verano: en azúl los que lo usan en el verano boreal, en naranja en el verano austral, en gris claro donde ya no se emplea y en gris oscuro donde nunca se empleó. Fuente: Wikipedia.3. Intervalos de tiempoSupón que estás creando un evento en tu calendario que debería repetirse en un día específico de cada mes; digamos que el quinto día. Muy probablemente, lo que harías es ir a tu calendario y marcar el 5 de octubre, el 5 de noviembre, el 5 de diciembre y así sucesivamente. Fácil, ¿verdad?Cambiemos un poco la ejemplo: ahora el evento se debería repetir cada 30 días. Siguiendo la instrucción, lo que deberías hacer es navegar en tu calendario contando los días a partir del día inicial y cuando llegues al día 30, marcarías la siguiente ocurrencia del evento. Es un poco más complejo, pero nada que no pudieras hacer a mano.Sin embargo, lo que estos ejemplos quieren ilustrar es que no hay una única manera de hacer aritmética con fechas y horas. En el primer caso, estamos tomando una interpretación cotidiana de las fechas, que tiene espacios de tiempo irregulares. Siguiendo el ejemplo, algunas veces vamos a tener 30 días entre los eventos y otras 31. En el segundo caso, estamos tomando una interpretación un poco más precisa, pero que no corresponde con nuestro día a día. Muy probablemente, a partir del siguiente mes el número del día no coincida.ConclusiónComo te puedes dar cuenta, en contra de lo que podría parecer a simple vista, la representación de una fecha no es algo trivial. Afortunadamente, lenguajes de programación como R y Python contienen paquetes que te permiten lidiar con todos estos aspectos fácilmente.Si quieres aprender a trabajar con lubridate en R, te invito a que leas este post que escribí. También te dejo los posts que escribí sobre datetime y pandas.Si te pareció útil, déjame un comentario abajo o comparte este post en tus redes. ¡Éxitos en tu aprendizaje!" }, { "title": "¿Cómo escribir un problema de optimización en Jupyter?", "url": "/posts/como-escribir-un-problema-de-optimizacion-en-jupyter/", "categories": "Jupyter", "tags": "jupyter, ecuaciones, mathjax, latex, markdown, tutorial", "date": "2022-11-21 15:15:00 -0500", "snippet": "Hace varias semanas compartí una entrada en el blog en la que hablaba sobre cómo escribir ecuaciones en Jupyter con LaTeX, en la que expliqué cómo escribir fracciones, superíndices, sumas, integral...", "content": "Hace varias semanas compartí una entrada en el blog en la que hablaba sobre cómo escribir ecuaciones en Jupyter con LaTeX, en la que expliqué cómo escribir fracciones, superíndices, sumas, integrales y otras expresiones comunes. En esta ocasión, te quiero explicar algunas funciones avanzadas de MathJax usando el problema clásico de maximización de utilidad de economía. Si tienes dudas sobre el ejemplo que voy a expicar a continuación, te invito a revisar el post en el que explico elementos básicos de MathJax, la implementación de LaTeX que funciona en Jupyter.Maximización de la UtilidadEn los cursos de economía, econometría o machine learning es normal encontrarnos con el planteamiento de problemas de optimización, en los que se pretende maximizar o minimizar una función objetivo –por ejemplo una función de utilidad o una función de costos– usando algún argumento de esa función y sujeto a alguna condición.En este ejemplo vas a aprender a escribir la maximización de una función de utilidad Cobb-Douglas sujeta a una restricción presupuestaria, muy común en los cursos introductorios de microeconomía:\\[\\begin{align}&amp;\\underset{x_1,x_2}{\\operatorname{max}}\\;U(x_1,x_2)=x_1^{\\alpha}x_2^{1-\\alpha}\\\\&amp;\\mathrm{s.a.}\\;p_1x_1+p_2x_2=w\\end{align}\\]Antes de seguir, quiero que notes varias cosas de esta expresión: La palabra $\\operatorname{max}$ y las letras $\\mathrm{s.a.}$ tienen un estilo sin cursiva, a diferencia del resto de letras de la ecuación. Los argumentos $x_1,x_2$ aparecen justo debajo de $\\operatorname{max}$ y con un tamaño de fuente un poco más pequeño. La restricción presupuestaria ($p_1x_1+p_2x_2=w$) está alineada al operador $\\operatorname{max}$ y no a la función de utlidad $U$.Veamos cómo implementar cada uno de estos comportamientos.Estilos de fuentePor defecto, los caracteres que aparecen en las ecuaciones de MathJax aparecen en cursiva. Sin embargo, no en todos los casos vas a querer trabajar de esta manera, como en el caso del ejemplo del problema de maximización de utilidad.En estos casos, es necesario usar la familia de funciones \\math_ incluidas en MathJax, que se resume en la siguiente tabla: Estilo Expresión Salida Cursiva ABCDEFabcdef o \\mathit{ABCDEFabcdef} $ABCDEFabcdef$ Negrilla \\mathbf{ABCDEFabcdef} $\\mathbf{ABCDEFabcdef}$ Redonda con serifas \\mathrm{ABCDEFabcdef} $\\mathrm{ABCDEFabcdef}$ Redonda sin serifas \\mathsf{ABCDEFabcdef} $\\mathsf{ABCDEFabcdef}$ Máquina de escribir \\mathtt{ABCDEFabcdef} $\\mathtt{ABCDEFabcdef}$ Caligrafía \\mathcal{ABCDEFabcdef} $\\mathcal{ABCDEFabcdef}$ Script \\mathscr{ABCDEFabcdef} $\\mathscr{ABCDEFabcdef}$ Fraktur \\mathfrak{ABCDEFabcdef} $\\mathfrak{ABCDEFabcdef}$ Negrilla de tablero \\mathbb{ABCDEFabcdef} $\\mathbb{ABCDEFabcdef}$ Para caracteres que se esceriben con una expresión –como \\alpha – hay que usar la función \\boldsymbol{} para ponerlas en negrilla. Por ejemplo, \\boldsymbol{\\alpha} devuelve $\\boldsymbol{\\alpha}$.Ahora bien, no siempre usar \\mathrm{} es la mejor opción para quitar la fuente cursiva a las ecuaciones. En particular, en lo que se refiere a operadores o nombres de funciones, es una buena idea usar la expresión \\operatorname{}, dado que incluye espacios antes y después del operador entre otros comportamientos específicos. Mientras que a\\mathrm{operador}b devuelve $a\\mathrm{operador}b$, a\\operatorname{operador}b devuelve $a\\operatorname{operador}b$.Underset y OversetMathJax incluye varios operadores para lidiar con elementos ubicados encima o debajo de la línea principal, tal como en el ejemplo de maximización de la utilidad.Similar a las fracciones, para usar estos operadores tenemos que usar la palabra clave \\underset (u \\overset) seguido de dos pares de corchetes. El primero denota el elemento que va debajo (o encima) y el segundo el elemento principal. Es decir: Expresión Salida \\underset{b}{A} $\\underset{b}{A}$ \\overset{b}{A} $\\overset{b}{A}$ AlineaciónPara la alineación horizontal de expresiones, tal como lo que sucede con la restricción presupuestaria, es necesario usar las expresiones \\begin{align}...\\end{align}, en conjunto con los caracteres &amp; y \\\\. Veamos cómo funciona.Para empezar, sólo lo que va dentro de \\begin{align} y \\end{align} va a seguir el comportamiento de alineación horizontal. Esto es útil porque como te vas a dar cuenta las expresiones en MathJax se pueden volver complejas con facilidad, por lo que es útil limitar los comportamientos especiales únicamente al lugar en el que los necesitamos.El caracter &amp; va a indicar los lugares de la expresión a donde se van a anclar cada una de las líneas para alinearse. Por su parte, \\\\ va a marcar el final de cada línea (algo parecido a oprimir Enter en tu teclado en Word).Sopongamos que tenemos la siguiente expresión, escrita en MathJax como w + x + y + z:\\[w + x + y + z\\]Al encerrarla así \\begin{align} w + x + y + z \\end{align}, no vas a ver ningún comportamiento especial, porque no le hemos indicado hasta dónde van las lineas y dónde tienen que alinease.\\[\\begin{align} w + x + y + z \\end{align}\\]Sin embargo, si incluimos \\\\, podemos separar las líneas de distintas formas: \\begin{align} w \\\\+ x + y + z \\end{align} devuelve:\\[\\begin{align} w \\\\+ x + y + z \\end{align}\\] \\begin{align} w + x\\\\ + y + z \\end{align} devuelve:\\[\\begin{align} w + x \\\\ + y + z \\end{align}\\] \\begin{align} w + x + y +\\\\ z \\end{align} devuelve\\[\\begin{align} w + x + y + \\\\z \\end{align}\\]Nota que por defecto las líneas se acomodan de tal forma que las líneas quedan con una justificación a la derecha. Puedes cambiar este comportamiento con el caracter &amp;.Tomemos el último ejemplo. Ouedes acomodar el lugar en el que aparece $+z$ de la siguiente manera: \\begin{align} &amp;w + x + y +\\\\ &amp;z \\end{align} devuelve\\[\\begin{align} &amp;w + x + y + \\\\&amp;z \\end{align}\\] \\begin{align} w + &amp;x + y +\\\\ &amp;z \\end{align} devuelve\\[\\begin{align} w + &amp;x + y + \\\\&amp;z \\end{align}\\] \\begin{align} w + x + &amp;y +\\\\ &amp;z \\end{align} devuelve\\[\\begin{align} w + x + &amp;y + \\\\&amp;z \\end{align}\\]Juntemos todoPongamos en práctica todo lo anterior. ¿Recuerdas los tres puntos que resalté al inicio del post? Vamos a implementarlos uno por uno. Comencemos por una expresión que no tenga el formato deseado. Algo comomax\\;x_1,x_2\\;U(x_1,x_2)=x_1^{\\alpha}x_2^{1-\\alpha}\\;s.a.\\;p_1x_1+p_2x_2=w\\[max\\;x_1,x_2\\;U(x_1,x_2)=x_1^{\\alpha}x_2^{1-\\alpha}\\;s.a.\\;p_1x_1+p_2x_2=w\\] Puedes ver que usé \\; varias veces en la expresión. Esta combinación de caracteres inserta un espacio en blanco entre las letras, que incluí para facilitar la legibilidad. Intenta escribirlo tú mismo sin estos caracteres para ver qué pasa.Lo primero es quitarle el formato en cursiva a $max$ y $s.a.$. Para el primero voy a usar la función \\operatorname y para el segundo \\mathrm así:\\operatorname{max}\\;x_1,x_2\\;U(x_1,x_2)=x_1^{\\alpha}x_2^{1-\\alpha}\\;\\mathrm{s.a.}\\;p_1x_1+p_2x_2=w.\\[\\operatorname{max}\\;x_1,x_2\\;U(x_1,x_2)=x_1^{\\alpha}x_2^{1-\\alpha}\\;\\mathrm{s.a.}\\;p_1x_1+p_2x_2=w\\]Lo siguiente es hacer que $x_1,x_2$ aparezcan debajo de $\\operatorname{max}$. Para ello, voy a usar \\underset de la siguiente manera:\\underset{x_1,x_2}{\\operatorname{max}}\\;U(x_1,x_2)=x_1^{\\alpha}x_2^{1-\\alpha}\\;\\mathrm{s.a.}\\;p_1x_1+p_2x_2=w\\[\\underset{x_1,x_2}{\\operatorname{max}}\\;U(x_1,x_2)=x_1^{\\alpha}x_2^{1-\\alpha}\\;\\mathrm{s.a.}\\;p_1x_1+p_2x_2=w\\]Ahora vamos a dejar la función objetivo y la restricción en líneas distintas, con \\begin{align}...\\end{align} y \\\\ así:\\begin{align}\\underset{x_1,x_2}{\\operatorname{max}}\\;U(x_1,x_2)=x_1^{\\alpha}x_2^{1-\\alpha}\\;\\\\\\mathrm{s.a.}\\;p_1x_1+p_2x_2=w\\end{align}\\[\\begin{align}\\underset{x_1,x_2}{\\operatorname{max}}\\;U(x_1,x_2)=x_1^{\\alpha}x_2^{1-\\alpha}\\;\\\\\\mathrm{s.a.}\\;p_1x_1+p_2x_2=w\\end{align}\\]Finalmente, vamos a alinear la restricción al operador $\\operatorname{max}$ con el caracter &amp;:$$\\begin{align}&amp;\\underset{x_1,x_2}{\\operatorname{max}}\\;U(x_1,x_2)=x_1^{\\alpha}x_2^{1-\\alpha}\\;\\\\&amp;\\mathrm{s.a.}\\;p_1x_1+p_2x_2=w\\end{align}$$\\[\\begin{align}&amp;\\underset{x_1,x_2}{\\operatorname{max}}\\;U(x_1,x_2)=x_1^{\\alpha}x_2^{1-\\alpha}\\;\\\\&amp;\\mathrm{s.a.}\\;p_1x_1+p_2x_2=w\\end{align}\\]ConclusiónAprendiste a cambiar el estilo de fuente, a poner elementos sonre otros y a alinear las líneas de tus expresiones con MathJax. Te invito a que experimentes con nuevas ecuaciones y veas qué tipo de comportamientos complejos logras escribir.Si te pareció útil, déjame un comentario abajo o comparte este post en tus redes. ¡Éxitos en tu aprendizaje!" }, { "title": "Args y Kwargs en Python", "url": "/posts/args-y-kwargs-en-python/", "categories": "Python", "tags": "python, args, kwargs, concepto, tutorial", "date": "2022-09-20 10:15:00 -0500", "snippet": "Uno de los primeros temas que probablemente abordaste al aprender a programar fue la creación de tus propias funciones. Estas ayudan a ordenar las instrucciones que plasmas en el código, a ahorrar ...", "content": "Uno de los primeros temas que probablemente abordaste al aprender a programar fue la creación de tus propias funciones. Estas ayudan a ordenar las instrucciones que plasmas en el código, a ahorrar espacio al no tener que repetir los mismos comandos varias veces, a disminuir la probabilidad de errores de tipeo porque sólo tienes que hacer la corrección en un lugar, etc. Sin embargo, puede que no hayas trabajado con los argumentos *args y **kwargs, que te van a ayudar cuando no sabes a ciencia cierta cuál será el número de argumentos de tu función.Un repasoAntes que nada, recordemos rápidamente cómo se crean funciones en Python. En su versión más básica, la definición de una función consiste en 3 elementos: la palabra clave def, seguida del nombre que le vas a asignar a la función; una lista de parámetros separados con coma dentro de un paréntesis, a su vez seguidos por el caracter de dos puntos, y el bloque de la función, que va a contener las instrucciones que quieres que realice. De manera esquemática, la creación de una función se ve algo como:def mi_funcion(lista_de_argumentos): # Bloque de código que describe su funcionamiento.A modo de ejemplo, si quisieras escribir una función que tome un input numérico y le sume 5, escribirías algo de la forma:def sumar_cinco(mi_numero): salida = mi_numero + 5 return salidaNota que en el ejemplo anterior añadí la palabra clave return, porque quiero que la función devuelva el resultado a mi entorno de trabajo y poder trabajar con él. Lo anterior se refiere únicamente a las funciones nombradas. En Python existen las funciones lambda, que son funciones anónimas y que generalmente se reservan para operaciones simples porque sólo pueden tener una expresión. Si quisieras escribir una función lambda para el ejemplo anterior, sería algo como: lambda x: x+5 Para añadir un número determinado de argumentos a la función, basta con separar los argumentos adicionales con coma. Por ejemplo, si quisieramos una función que multiplicara cuatro números que damos como input, podríamos hacer algo como:def multiplicacion_de_cuatro(arg1, arg2, arg3, arg4): return arg1 * arg2 * arg3 * arg4No obstante, esta función serviría únicamente para las multiplicaciones en las que conoces de antemano que vas a tener exactamente 4 factores. En caso de no tenerlos, Python te devolvería un error al momento de llamar la función. En escenarios como estos, *args y **kwargs muestran su utilidad.*argsEl argumento *args sirve para referirse a una lista de longitud variable de argumentos en la definición de una función. Es decir, no importa si son 2, 5, 10 o 100 argumentos; la función podrá lidiar con esa lista sin que sea necesario definir explícitamente el número de argumentos al momento de su creación.Sigamos con el ejemplo de la multiplicación. Ya viste en el caso en que definíamos una multiplicación con un número determinado de argumentos. Para crear una función productoria, tenemos que emplear una lista variable de argumentos con *args. Una opción sería escribir algo así:def productoria(*args): salida = 1 for arg in args: salida *= arg return salida Por si no lo habías visto, el operador *= que uso en el bloque de la función sirve para abreviar la operación de asignación y de multiplicación. Pude haber escrito esa misma línea como: salida = arg * salida.Quiero que veas dos cosas. Primero, que si bien incluimos la mención a *args con el asterisco al interior de los paréntesis, cuando nos referimos a esta lista arbitraria en el bloque de la función no tenemos que hacerlo; podemos escribir únicamente args. Esto es porque cuando se usa un asterisco antes de un elemento iterable –como una lista–, este se convierte en su propio operador: el unpacking operator u operador de desempacado. El comportamiento de este operador da para un post aparte, pero si quieres leer más al respecto puedes revisar este artículoSegundo, que trabajar con una lista variable de argumentos implica cambiar la forma en la que construyes tu función. Ya no puedes definir directamente la multiplicación, justamente porque no conoces de antemano el número de factores. En este caso, tienes que determinar un punto de partida en 1 e iterar a lo largo de los elementos de la lista de longitud variable de argumentos. Si bien este puede no ser el ejemplo más complejo, sirve para ilustrar este cambio de lógica.**kwargsLa lógica del argumento **kwargs es muy parecida, sólo que cambia un poco la sintaxis. En vez de definir la lista como antes, ahora se va a definir a través de parejas key = value. De ahí el kw de **kwargs; es por que son argumentos que van con su palabra clave o keyword.En estricto sentido, mientras lo que va en el lugar de *args se comportaba como una lista o una tupla de Python, por lo que se puede iterar de la manera anterior; lo que va en lugar de **kwargs se comporta como un diccionario. Es decir, que podemos acceder a los elementos usando los métodos .items(), .keys() o .values().Veamos un ejemplo. Supongamos que queremos una función que imprima una serie de atributos para una persona: nombre, apellido y edad. Si sabemos que es exactamente ese número de elementos, podemos escribir algo como:def imprimir_caracteristicas(nombre, apellido, mascota): print(\"Nombre:\", nombre) print(\"Apellido:\", apellido) print(\"Mascota:\", mascota)imprimir_caracteristicas(\"Camilo\", \"Martinez\", \"Gato\")Ahora bien, si tenemos un número variable de atributos nos enfrentamos con el mismo problema de antes. No los podemos definir explícitamente porque no sabemos cuántos son. Aquí podemos usar **kwargs.def imprimir_caracteristicas_v2(**kwargs): for (key, value) in kwargs.items(): print(f'{key}: {value}')imprimir_caracteristicas_v2(nombre = \"Camilo\", apellido = \"Martínez\", mascota = \"Gato\", nacionalidad = \"Colombia\", color_favorito = \"Azul\")Todo juntoPor supuesto, todo lo que has visto se puede usar a la vez, incluso con los argumentos tradicionales sin el operador *. Veamos un ejemplo más complejo.Supongamos que quieres crear una función que me imprima a la consola la descripción de un curso en un colegio específico. Esa función tendrá como inputs el nombre del Colegio, el nombre del curso, los alumnos que están matriculados en ese curso y las clases que tienen que ver en el día. Vamos a construirla por partes.Primero, creemos una función simple que imprima en consola el nombre del colegio y el nombre del curso:def descripcion_curso(nombre_colegio, nombre_curso): print(f'Este es el resumen del curso {nombre_curso} del {nombre_colegio}.')descripcion_curso(\"Colegio Pepito Pérez\", \"4B\")Ahora continuemos escribiendo una lista de longitud arbitraria de estudiantes que están matriculados en ese curso usando *args:def descripcion_curso(nombre_colegio, nombre_curso, *args): print(f'Este es el resumen del curso {nombre_curso} del {nombre_colegio}.') print(f'Estas son las personas matriculadas: {\", \".join(args)}')descripcion_curso(\"Colegio Pepito Pérez\", \"4B\", \"Ana\", \"Juan\", \"Maria\", \"Carlos\")Finalmente, incluyamos las clases que tienen que ver en el día usando **kwargs:def descripcion_curso(nombre_colegio, nombre_curso, *args, **kwargs): print(f'Este es el resumen del curso {nombre_curso} del {nombre_colegio}.') print(f'Estas son las personas matriculadas: {\", \".join(args)}') print('Estas son las clases del día:') for (key, value) in kwargs.items(): print(f'{key}: {value}')descripcion_curso(\"Colegio Pepito Perez\", \"4B\", \"Ana\", \"Juan\", \"Carlos\", \"Maria\", mañana = \"Biología\", tarde = \"Matemáticas\") No necesariamente te vas a encontrar con un ejemplo de este estilo en la vida real. Sin embargo, cuando estés utilizando esos tres tipos de argumentos es muy importante preservar el orden: Primero argumentos posicionales, luego *args y luego **kwargs. Adicionalmente, para este ejemplo específico, no puedes llamar el nombre de los argumentos posicionales –p.e. escribiendo descripcion_curso(nombre_colegio = \"Colegio Pepito Pérez\")– porque te generará un error al tener argumentos posicionales después de argumentos con palabra clave. Puedes leer más al respecto acá.ConclusiónEspero que te hayan quedado más claros los conceptos de *args y **kwargs. Te dejo la tarea de experimentar y crear funciones más complejas que hagan uso de estas listas de parámetros de tamaño variable. Si te gustó, te invito a dejarme un comentario y a compartir este artículo en tus redes sociales." }, { "title": "La anatomía de un gráfico", "url": "/posts/la-anatomia-de-un-grafico/", "categories": "Dataviz", "tags": "ggplot, gramática, estructura, concepto", "date": "2022-09-03 15:35:00 -0500", "snippet": "En diversas aplicaciones de visualización de datos, la creación de un gráfico se limita a dar clic a un botón que te muestra directamente el resultado final. Si bien esto es muy conveniente desde e...", "content": "En diversas aplicaciones de visualización de datos, la creación de un gráfico se limita a dar clic a un botón que te muestra directamente el resultado final. Si bien esto es muy conveniente desde el punto de vista de un usuario ocasional, también te puede quitar la posibilidad de entender con más detalle los elementos que hacen que un gráfico funcione. Por esta razón, hoy quiero hablarte de la Gramática de los Gráficos.La gramática de los gráficosLa gramática de los gráficos es un esquema desarrollado por Claus Wilke en un libro homónimo, en el que detalla los elementos que constituyen un gráfico. Si has trabajado con {ggplot2} en R, verás que ya tienes un entendimiento intuitivo de estos elementos, dado que este paquete se construyó con base en las lógicas de este esquema –de ahí el ‘gg’ de ‘ggplot’, Grammar of Graphics–.En lo que sigue de esta entrada de blog, voy a seguir la explicación que hacen en el libro de ggplot2: Elegant Graphics for Data Analysis, porque considero que tiene una explicación un poco más sencilla y menos técnica que el libro de Wilke.Datos y mapeoDe acuerdo con este esquema, los gráficos se componen de dos elementos clave: datos y mapeo.Los datos son la información que se va a transformar en un formato visual para que tu audiencia los pueda consumir. Si lo pensamos como una pregunta, los datos son el ¿qué?.Por su parte, el mapeo –o mapping en inglés– es la forma en la que se va a realizar esa transformación. Es decir, son el ¿cómo? El mapeo se compone de los siguientes 5 elementos: capas, escalas, coordenadas, facetas y tema.a. CapasLas capas son las geometrías que ves directamente en el gráfico, que están asociadas a un estadístico construido a partir de los datos: una identidad, una media, una mediana, un conteo de observaciones, etc.Por ejemplo, la capa que caracteriza a un gráfico de dispersión es un conjunto de puntos que muestran un valor que está en los datos originales, mientras que la capa que caracteriza a un gráfico de columnas es un conjunto de barras que pueden estár asocadas al conteo de observaciones en ciertos rangos de valores de una variable.b. EscalasLas escalas describen la forma en que se presentan las capas de manera visual en el gráfico. Puedes tener escalas de posición (ejes x, y, o z), de color, de tamaño, de forma, de tipo de línea, etc. Estas escalas pueden ser discretas o contínuas, dependiendo de los datos y del mensaje que quieras enviar con el gráfico.Siguiendo el ejemplo anterior, en un gráfico de dispersión se suele trabajar con unos ejes x e y contínuos, mientras que en el gráfico de columnas suele aparece un eje x discreto y un eje y contínuo. Lo anterior, al margen de que quieras añadir más información coloreando los elementos del gráfico según una variable adicional.c. CoordenadasEl sistema de coordenadas describe la forma cómo esas escalas y esas geometrías se pintan en el plano del gráfico, asumiendo uno en dos dimensiones. En general, el sistema de coordenadas que te vas a encontrar es el de las coordenadas cartesianas, pero cuando lidies con mapas y otras visualizaciones especiales, trendrás otros tipos de coordenadas.d. FacetasLas facetas definen la manera como se pueden dividir los elementos anteriores en gráficos más pequeños. Es decir, cuando pasas de tener un gran lienzo donde se pintas todos los datos a lienzos más pequeños, separados de acuerdo con alguna variable categórica.Por ejemplo, si tienes una variable asociada al continente para el gráfico de dispersión, podrías presentar toda la información en un sólo gráfico, o separarlo en varios gráficos del mismo tipo de acuerdo con dicha variable.e. TemaPor último, el tema controla todos los demás elementos estéticos que intervienen en la manera como se ve el gráfico. Colores de los títulos, tamaño del texto, si el gráfico tiene o no un borde, etc.Si estamos hablando de un gráfico de tiplo exploratorio, quizás el tema no es el elemento más importante. Sin embargo, para un gráfico con fines de publicación o divulgación, este cobra más importacia para capturar la atención de tu audiencia y transmitir los mensajes correctos.No te preocupes si estos conceptos no te quedaron claros con una primera leída. Te voy a mostrar algunos ejemplos para que sea un poco más evidente.EjemplosTodos los ejemplos que te muestro a continuación los extraje del blog de Datawrapper. Este es un excelente recurso para que revises si quieres un poco de inspiración para armar tus gráficos.Ejemplo 1Este gráfico muestra las respuestas de las personas encuestadas por Pew Research Center en varios países, con respecto a los aspectos que le dan sentido a sus vidas. Te invito a que, antes de seguir, le des una mirada al gráfico y trates de extraer los elementos que se describen con anterioridad.Fuente: https://blog.datawrapper.de/meaning-of-life-international-survey/Veamos cada uno de los elementos por separado: Capas. Como puedes ver, la geometría que se usa para mostrar los datos es un conjunto de puntos. Escalas. Tenemos 3 escalas que conviven en el gráfico: La escala x contínua que muestra el porcentaje de respuestas que incluyeron cada uno de los asuntos. La escala y discreta con los países en los que se realizó la encuesta y, La escala de color discreto que describe los asuntos puntuales como mascotas, pareja, etc. Coordenadas. En este caso, el sistema de coordenadas es cartesiano. Facetas. Tenemos un solo lienzo, es decir sólo una faceta. Tema. Todos los elementos adicionales, como que el título sea más grande que el resto de texto y esté en negrilla, que el fondo sea blanco, que la nota al ginal del gráfico esté en color gris, etc.Fuente: Elaboración propia con base en https://blog.datawrapper.de/meaning-of-life-international-survey/Ejemplo 2Este gráfico muestra la red de ciclorrutas en 6 ciudades del mundo. Repite el ejercicio anterior y abajo te muestro el resultado.Fuente: https://blog.datawrapper.de/international-bike-lanes-maps/Veamos: Capas. Este pudo ser un poco más dificil de abstraer, pero en general los mapas usan puntos, líneas y polígonos para mostrar los datos georreferenciados. En este caso, ignorando el mapa de fondo, el borde de cada ciudad es un polígono y las ciclorrutas se representan con líneas. Escalas. A pesar de que ya no estamos trabajando con un gráfico como el de arriba, las escalas son de posición: ejes x e y contínuos. Podríamos pensar también que los colores del polígono (gris) y de las líneas (morado) son una escapa de color, aunque no parecen estar asociadas a una variable específica en los datos. Coordenadas. Como lo mencionaba con anterioridad, cuando hablamos de mapas las coordenadas ya no son cartesianas sino alguna proyección específica del volúmen tridimensional de la tierra, que no conocemos. Facetas. En este caso, tenemos un mapa similar para 6 ciudades distintas. Entonces podemos hablar de que tenemos 6 facetas separadas. Tema. Tenemos el color de fondo en blanco, el nombre de las ciudades un poco más grande que el resto de texto y el subtítulo para cada ciudad en morado.Fuente: Elaboración propia con base en https://blog.datawrapper.de/international-bike-lanes-maps/Ejemplo 3Vamos con el último. Los dos gráficos muestran el recorrido de las rutas de avión de Tokyio a Londres y París, y cómo se redirigieron para no pasar por espacio aéreo Ruso. Ambos gráficos contienen la misma información pero diferen en sólo uno de los elementos del mapeo. ¿Cuál crees que es?Fuente: https://blog.datawrapper.de/flight-routes-map-projections/ Capas. Estos mapas emplean las 3 geometrías básicas de los mapas: puntos, líneas y polígonos. Escalas. Al igual que el ejemplo anterior, se están pintando los mapas en unas escalas x e y contínuas. Coordenadas. Esta es la principal diferencia entre los dos. Mientras el primero utiliza una proyección llamada Mercator Web, el segundo usa una proyección ortográfica. Facetas. Como ambos mapas están por separado, podemos decir que tienen 1 faceta cada uno. Tema. No podemos decir mucho del tema más allá del color de fondo y el formato de la letra de las etiquetas de las ciudades y los vuelos.ConclusiónCon esto, ya deberías poder identificar los elementos de la Gramática de los Gráficos en las visualizaciones que te encuentres. Pensar explícitamente en la estructura de un gráfico te va a ayudar a mejorar su diseño y, por qué no, romper algunas reglas para generar productos aún más interesantes.Te invito a compartir este post en tus redes si te pareció útil y a que practiques los ejercicios de los ejemplos con gráficos que te encuentres en tu día a día." }, { "title": "La guía definitiva para escribir ecuaciones en Jupyter", "url": "/posts/la-guia-definitiva-para-escribir-ecuaciones-en-jupyter/", "categories": "Jupyter", "tags": "jupyter, ecuaciones, mathjax, latex, markdown, tutorial", "date": "2022-07-19 16:15:00 -0500", "snippet": "Escribir ecuaciones como las que puedes encontrar en un libro de texto o una publicación académica parece un asunto complejo. Sin embargo, con MathJax esta tarea se vuelve muy sencilla y al final d...", "content": "Escribir ecuaciones como las que puedes encontrar en un libro de texto o una publicación académica parece un asunto complejo. Sin embargo, con MathJax esta tarea se vuelve muy sencilla y al final de este post podrás crear ecuaciones para tus cuadernos de Jupyter y tus documentos de Markdown.¿Qué es MathJax?MathJax es un motor para la visualización de ecuaciones en Javascript que funciona con la notación de LaTeX, que funciona en todos los navegadores de internet modenos. De acuerdo con la documentación de este motor: “Uno sólo debe incluir MathJax y matemáticas en una página web, y MathJax se encarga del resto.”Este motor se usa tanto en Jupyter como en el Markdown usado por Github, así que sin duda va a ser una herramienta muy útil para que aprendas a usarla.Antes de entrar en detalle sobre las expresiones que te permitirán escribir símbolos para tus ecuaciones, tienes que saber dos cosas: qué es lo que procesa MathJax en ecuaciones y cómo agrupa los elementos en una expresión que escribas.Delimitar una ecuaciónLo primero que hay que indicarle a MathJax es cuáles caracteres corresponden a una ecuación que queremos mostrar en pantalla. Para ello, tenemos dos opciones: ecuaciones en la misma línea o ecuaciones en línea propia.En el primer caso, vamos a mostrar la ecuación siguiendo el mismo renglón, lo que puede servir para mostrar algún símbolo en específico o una ecuación corta. Esto lo hacemos encerrando los caracteres entre símbolos de pesos $. Por ejemplo, podemos escribir la ecuación $x=0$ al digitar $x=0$.En el segundo, mostramos la ecuación en un renglón aparte, lo que es especialmente útil para ecuaciones grandes. Lo único que tenemos que hacer es crear una nueva línea y encerrar los caracteres en doble símbolo de pesos $$. Entonces, el resultado de escribir la misma ecuación de arriba digitando $$x=0$$ es:\\[x=0\\] Si no dejas estos caracteres encerrados por doble paréntesis en una nueva línea, no se mostrará la ecuación como arriba.GruposLo otro que es importante aprender es la forma en que MathJax lidia con grupos de caracteres. Dado que necesitamos escribir ecuaciones de manera precisa, este motor agrupa elementos usando los corchetes: {}. Veamos un ejemplo.Supón que quieres escribir una constante a elevada a una potencia de 20. Lo primero que se te puede venir a la cabeza es escribir algo como $a^20$. No obstante, lo que mostraría MathJax sería esto $a^20$. Esto sucede porque el motor lidia con los caracteres uno por uno.Para mostrar correctamente la potencia, tienes que agrupar los caracteres del 20 de la siguiente manera $a^{20}$ para tener lo que esperabas: $a^{20}$.Por este motivo, de ahora en adelante vas a ver de manera recurrente el uso de los corchetes en muchas fórmulas. Ahora si, veamos cómo construir ecuaciones más complejas.Operadores básicosMathJax cuenta con un gran número de símbolos para denotar operadores. Acá te dejo una lista no exhaustiva de ellos, la mayoría de los cuales se escriben con un \\, seguido de una secuencia específica de caracteres.Aritméticos Expresión Salida a + b $a + b$ a - b $a-b$ a \\times b $a \\times b$ a \\pm b $a \\pm b$ a ^ b $a ^ b$ a \\pm b $a \\pm b$ Comparación Expresión Salida a \\lt b $a \\lt b$ a \\gt b $a \\gt b$ a \\le b $a \\le b$ a \\ge b $a \\ge b$ a = b $a = b$ a \\neq b $a \\neq b$ Conjuntos Expresión Salida A \\cup B $A \\cup B$ A \\cap B $A \\cap B$ A \\setminus B $A \\setminus B$ A \\subset B $A \\subset B$ A \\subseteq B $A \\subseteq B$ A \\subsetneq B $A \\subsetneq B$ A \\supset B $A \\supset B$ A \\supseteq B $A \\supseteq B$ A \\supsetneq B $A \\supsetneq B$ A \\in B $A \\in B$ A \\notin B $A \\notin B$ \\emptyset $\\emptyset$ \\varnothing $\\varnothing$ Lógicos Expresión Salida p \\land q $p \\land b$ p \\lor q $p \\lor b$ \\lnot p $\\lnot p$ \\foraall b $\\forall p$ \\exists p $\\exists p$ \\top $\\top$ \\bot $\\bot$ \\vdash $\\vdash$ \\Vdash $\\Vdash$ Subindices y SuperíndicesCuando escribes ecuaciones te puedes encontrar con una notación que implique añadir información adicional a una variable, como $a_i$, $b^2$ o $\\hat{c}$. Los elementos que van sobre la variable se llaman superíndices y los que van debajo subíndices.Para escribir un subíndice necesitas poner la variable seguida de un _ y el caracter o caracteres que hacen parte del subíndice. La expresión $a_i$ es el resultado de $a_i$.Por su parte, para los superíndices, debes escribir la variable principal seguida de ^ y el caracter o caracteres que hacen parte de tu superíndice. Para mostrar $b^2$ escribí $b^2$. No olvides usar correctamente los corchetes. Si tienes varios caracteres en el mismo subíndice o superíndice, es necesario que los encierres con {}.Por último, hay algunas funciones que te permiten escribir caracteres especiales como $\\hat{c}$ sobre las variables. En la siguiente tabla encuentras algunos de ellos: Expresión Salida \\hat{x} o \\widehat{x} $\\hat{x}$ \\bar{x} o \\overline{x} $\\bar{x}$ \\dot{x} $\\dot{x}$ \\ddot{x} $\\ddot{x}$ \\vec{x} $\\vec{x}$ \\overtightarrow{x} $\\overrightarrow{xy}$ \\overleftarrow{x} $\\overleftarrow{xy}$ \\overleftrightarrow{x} $\\overleftrightarrow{xy}$ La diferencia entre \\hat{x} y \\widehat{x} es que el primero sólo funciona para un caracter y el segundo para varios. Esto mismo aplica para \\bar{x} o \\overline{x}.FraccionesTe voy a mostrar dos formas para escribir fracciones de este estilo:\\[{a\\over b}\\]La primera es usando la forma \\frac{a}{b}, que te permite poner en corchetes aparte el numerador y el denominador.La segunda es incluyendo tanto el numerador como el denominador en el mismo grupo con la estructura {a\\over b}.En algunos casos puede ser más fácil trabajar de la sergunda forma, especialmente cuando tienes ecuaciones complejas.Tema aparte son las fracciones contínuas como esta\\[x = a_0 + \\cfrac{b_1}{a_1 + \\cfrac{b_2}{a_2 + \\cfrac{b_3}{...}}}\\]que tienen su propia función: \\cfrac{}{}. La ecuación anterior la generé usando:$$x = a_0 + \\cfrac{b_1}{a_1 + \\cfrac{b_2}{a_2 + \\cfrac{b_3}{...}}}$$ Las ecuaciones con fracciones contínuas se pueden volver complejas muy rápido. Ten mucho cuidado con el uso de los corchetes y cómo estás encadenando las expresiones \\cfrac{}{}.ParéntesisLa manera de escribir paréntesis va a depender de si lo que quieres hacer es envolver elementos que ocupan una o más líneas.Para una sola línea, basta con escribir los caracteres normales (), [] o para el caso de los corchetes \\{ y \\}. Estos símbolos adicionales son para indicarle a MathJax que queremos mostrar un corchete y no que estamos armando un grupo. Así podemos cosntruir cosas como $(a+b)$.Si hablamos de varias líneas - por ejemplo para fracciones - tenemos que añadir \\left y \\right a esos símbolos. Supón que quieres escribir siguiente fracción entre paréntesis:\\[{x+1\\over 2}\\]Si escribes únicamente $({x+1\\over 2})$ vas a tener el siguiente resultado.\\[({x+1\\over 2})\\]Pero si escribes $\\left({x+1\\over 2}\\right)$ tendrás:\\[\\left({x+1\\over 2}\\right)\\]Aquí algunos símbolos adicionales que se comportan con la misma lógica de los paréntesis: Expresión Salida |x| $|x|$ \\vert x \\vert $\\vert x \\vert$ \\Vert x \\Vert $\\Vert x \\Vert$ \\langle x \\rangle $\\langle x\\rangle$ \\lceil x \\rceil $\\lceil x \\rceil$ \\lfloor x \\rfloor $\\lfloor x \\rfloor$ Funciones nombradasSi bien podrías pensar que sólo necesitas escribir algo como $sin(x)$, usualmente las letras de estas funciones no se escriben en cursiva. Por tal motivo, hay expresiones especiales para \\sin, \\cos, \\tan y otras como \\ln, \\max y \\min. Mira la diferencia entre escribir $sin(x)$ - $sin(x)$ - y $\\sin(x)$ - $\\sin(x)$ -.LimitesAlgo similar sucede con los límites -tienen la expresión \\lim-, sólo que en este caso es necesario añadir el elemento que va debajo con _. Por ejemplo, si quieres escribir la definición del número de Euler\\[\\lim_{x\\to\\infty} \\left(1 + {1\\over n}\\right)^n\\]deberías escribir algo como:$$\\lim_{x\\to\\infty} \\left(1 + {1\\over n}\\right)^n$$ Como pouedes ver, la flecha hacia la derecha que indica hasta dónde va el límite ($\\to$) se escribe \\to y el símbolo de infinito ($\\infty$) con \\infty.Sumas e IntegralesEstos símbolos usualmente incluyen unos elementos arriba y abajo, por lo que tienes que usar de manera simultánea los operadores de subíndice (_) y superíndice (^).Por ejemplo, escribir $\\sum_{n = 1}^{100} n$ te dará como resultado:\\[\\sum_{n = 1}^{100} n\\]En la siguiente tabla hay una lista de símbolos que se comportan de la misma manera. Expresión Salida \\int $\\int$ \\iint $\\iint$ \\iint $\\iiint$ \\prod $\\prod$ \\bigcup $\\bigcup$ \\bigcap $\\bigcap$ ConclusiónYa tienes una guía para empezar a escribir ecuaciones tan complejas como quieras, y así complementar tus documentos de Markdown o tus cuadernos de Jupyter.Por supuesto, hay muchos más símbolos y ajustes que puedes hacer que no cubrí en este post. Te invito a consultar este artículo de referencia en el que se entra más en detalle sobre MathJax.Si te pareció útil, déjame un comentario abajo o comparte este post en tus redes. ¡Éxitos en tu aprendizaje!" }, { "title": "Crea tu propia plantilla en Cookiecutter", "url": "/posts/crea-tu-propia-plantilla-en-cookiecutter/", "categories": "Cookiecutter", "tags": "cookiecutter, plantilla, proyecto, tutorial", "date": "2022-07-11 14:00:00 -0500", "snippet": "En una entrada de blog anterior te compartí dos plantillas para proyectos de ciencia de datos que hice en Cookiecutter. En esta ocasión quiero enseñarte cómo puedes crear tus propias plantillas y a...", "content": "En una entrada de blog anterior te compartí dos plantillas para proyectos de ciencia de datos que hice en Cookiecutter. En esta ocasión quiero enseñarte cómo puedes crear tus propias plantillas y ajustarlas a tu flujo de trabajo específico.Antes de empezar, debes tener Python y Cookiecutter instalado tu computador. Para ver cómo se hace puedes ir a la sección correspondiente del post original o consultar la documentación de Cookiecutter.SintaxisLo primero que debes saber es que Cookiecutter usa una sintaxis especial que viene de Jinja, el motor de plantillas en el que está escrito. Dado que el código de la plantilla tiene que convivir con código en otros lenguajes de programación, es muy importante poder diferenciar lo que está escrito en Jinja de lo que no.Por tal razón, las lineas con las que vas a personalizar tu plantilla están encerradas en corchetes ({}). En adelante me voy a referir a las líneas de Jinja como bloques.Dependiendo los caracteres que delimiten esos bloques, vas a lograr distintas funciones: Para imprimir el contenido en la salida de la plantilla, vas a encerrar el código en doble corchete: {{...}}. Por ejemplo, si quieres llamar la variable autor de la plantilla, tienes que escribir algo como {{ cookiecutter.autor }}. Para usar estructuras de control como if o for, encierras el código en corchetes y signos de porcentaje: {%...%}. Dependiendo de la estructura de control, también vas a tener que cerrar con un {% endif %} o {% endfor %}. Por ejemplo: {% if cookiecutter.condicion %}¡Muestra esto!{% endif %} Para incluir un comentario, encierras el contenido en corchetes y numerales: {#...#}: {# Esto es un comentario #}. Creación de la plantillaTeniendo lo anterior, vas a crear una nueva carpeta, que en adelante llamaré la carpeta madre, y dentro de ella una con este nombre: {{ cookiecutter.project_slug }}. Ahora que entiendes la sintaxis de Jinja, ya puedes intuir que esta última se va a llamar según el contenido de la variable project_slug. Más adelante veremos la configuración de esta y otras variables.Ahora, dentro de esa carpeta {{ cookiecutter.project_slug }} que creaste vas a organizar la estructura de tu espacio de trabajo: carpetas y subcarpetas, .gitignore, un README.md, cuadernos de jupyter, etc. A partir de ésta es que se generará tu proyecto.Al interior de los archivos que crees vas a poder trabajar con los bloques de Jinja que viste antes. Por ejemplo, para que el README.md de tu proyecto tenga un nombre y una descripción personalizada, puedes escribir en ese archivo algo como:# {{ cookiecutter.project_title }}Autor: {{ cookiecutter.project_author_name }}{{ cookiecutter.project_description }}Configuración de variablesNaturalmente, para que la plantilla funcione todas las variables que llamas tienen que existir. Para ello, en la carpeta {{ cookiecutter.project_slug }} tienes que crear un archivo llamado cookiecutter.json. Usando líneas como las que están a continuación vas a enumerar las variables para tu proyecto, que a su vez serán las que la consola te va a preguntar cuando generes un proyecto a partir de la plantilla.{\t\"project_title\": \"Mi plantilla\",\t\"project_slug\": \"{{ cookiecutter.project_title.lower().replace(' ', '_').replace('-', '_') }}\",\t\"project_description\": \"Acá va la descripción.\",\t\"project_author_name\": \"Tu nombre\"}En esta configuración, tenemos una variable para el título del proyecto, una variable para un apodo del proyecto que se genera automáticamente con un par de funciones de Python, una descripción para el proyecto y el nombre de quien lo creó. Si no añades información en la consola, éste tomará los valores por defecto que aparecen arriba.Con lo anterior, puedes configurar comportamientos tan complejos como quieras. Por ejemplo, podrías crear una variable que pregunte si quieres incluir ciertas librerías de Python en tu proyecto e incluir unos bloques {% if ... %} {% endif %} en un archivo environment.yml para luego instalarlas con Conda.El límite es tu creatividad y lo granular que quieras llegar a ser con el comportamiento de la plantilla.HooksFinalmente, Cookiecutter también incluye una funcionalidad para ejecutar código antes y después de generar el proyecto con base en la plantilla. A esto se le llama Hooks.En síntesis, son líneas de código de Python que incluyes en scripts llamados pre_gen_project.py o post_gen_project.py - dependiendo el comportamiento que quieras que hagan - y que se alojan en una carpeta llamada hooks en la carpeta madre. ¡Ojo! Estos scripts NO van en la carpeta {{ cookiecutter.project_slug }}.Usando hooks, puedes hacer cosas como generar automáticamente un repositorio de Git:import subprocesssubprocess.call(['git', 'init'])subprocess.call(['git', 'add', '*'])subprocess.call(['git', 'commit', '-m', 'Initial commit'])ConclusiónLuego de configurar tu plantilla, puedes conservar la carpeta madre en tu máquina local o subirla a un repositorio de github para llamarla de manera remota. Si la plantilla quedó creada correctamente, vas a poder crear un proyecto con base en ella corriendo el siguiente comando en consola:# Si está en tu máquina localcookiecutter &lt;Ruta de Archivo&gt;# Si está en Gitubcookiecutter &lt;URL del repositorio&gt;Espero que te animes a crear tus propias plantillas y te deseo buena suerte experimentando con esta herramienta. Si te pareció de utilidad esta entrada no olvides compartir o dejarme un comentario." }, { "title": "4 paquetes para mejorar tus gráficos en ggplot2", "url": "/posts/4-paquetes-para-mejorar-tus-graficos-en-ggplot2/", "categories": "R", "tags": "r, ggplot2, extensiones, paquetes, dataviz", "date": "2022-06-26 15:00:00 -0500", "snippet": "Hace algunos meses decidí participar en el #30DayChartChallenge, un desafío propuesto por Dominic Royé y Cédric Scherer que consistía en realizar un gráfico durante cada día de Abril con una temáti...", "content": "Hace algunos meses decidí participar en el #30DayChartChallenge, un desafío propuesto por Dominic Royé y Cédric Scherer que consistía en realizar un gráfico durante cada día de Abril con una temática específica.Aunque no logré completar los 30 días, durante este desafío pude potenciar mis conocimientos en ggplot2, y de paso, conocí varios paquetes que permiten extender la funcionalidad de este maravilloso paquete para crear gráficos aún más interesantes.En este blog quiero compartir contigo 4 paquetes que me utilicé y que espero que te gusten. Encontrarás los enlaces a la documentación de los paquetes al final del post.1. ggtextggtext es un paquete que aumenta las posibilidades para dar formato a textos en ggplot2, al incluir funcionalidades propias de Markdown y HTML. La funcionalidad que más utilicé durante el desafío fue definir colores y estilos para palabras específicas, cosa que no se puede hacer usando la función theme(). Por ejemplo:Figura 1. Ejemplo ggtext.Para ello, debes usar también el paquete glue(), incluir un par de etiquetas de HTML a tu texto normal y definir el texto que modificaste como un element_markdown() en la función theme().library(ggtext)library(glue)# Gráfico básicoggplot(iris, aes(x=Petal.Length, y = Petal.Width)) + geom_point() + labs( title = \"Longitud vs Ancho de pétalo\", x = \"Longitud\", y = \"Ancho\" )# Gráfico con ggtextggplot(iris, aes(x=Petal.Length, y = Petal.Width)) + geom_point() + labs( title = glue(\"&lt;i style='color:\\\"red\\\"'&gt;Longitud&lt;/i&gt; vs &lt;b style='color:\\\"blue\\\"'&gt;ancho&lt;/b&gt; del &lt;b style='color:\\\"darkgreen\\\"'&gt;pétalo&lt;/b&gt;\"), x = glue(\"**Longitud**\"), y = glue(\"*Ancho*\") ) + theme( plot.title = element_markdown(), axis.title.x = element_markdown(), axis.title.y = element_markdown() ) En la versión más reciente de R (4.2.0), ggtext tiene problemas para mostrar los textos en negrilla y cursiva. Si encuentras este problema, instala la versión más reciente de gridtext con el comando remotes::install_github(\"wilkelab/gridtext\")2. ggrepel¿Te ha pasado que intentas poner etiquetas en un gráfico pero aparecen demasiadas y muy cerca unas de otras? Este paquete también se centra en el trabajo con textos y mejora la ubicación de las etiquetas en el gráfico, al definir una fuerza que las repele entre si.Figura 2. Ejemplo ggrepel.Como se puede ver, ggrepel automáticamante oculta las etiquetas que estén muy cerca, de acuerdo con los parámetros asociados a la fuerza descrita y otdena las etiquetas restantes de tal manera que no se sobrelapen entre si. Lo único que se necesita es reemplazar la función geom_label() por geom_label_repel(). Este paquete también permite cambiar geom_text() por geom_text_repel().El código para generar estos gráficos es el siguiente:library(ggrepel)library(gapminder)gapminder_2007 &lt;- gapminder %&gt;% filter(year == 2007)# Gráfico básicoggplot(gapminder_2007 ,aes(lifeExp, gdpPercap, label = country)) + geom_point() + geom_label() + labs( title = \"Expectativa de vida vs GDP per cápita\", x = \"Expectativa de vida\", y = \"GDP per cápita\" )# Gráfico con ggrepelggplot(gapminder_2007 ,aes(lifeExp, gdpPercap, label = country)) + geom_point() + geom_label_repel() + labs( title = \"Expectativa de vida vs GDP per cápita\", x = \"Expectativa de vida\", y = \"GDP per cápita\" )3. patchworkSi bien ggplot2 tiene herramientas poderosas para modificar granularmente cada uno de los componentes de un gráfico, no es tan fácil generar una salida que contenga múltiples gráficos a la vez. Especialmente cuando quieres ir más allá de las funciones facet_grid() o facet_wrap().El paquete patchwork entra a llenar este vacío y te permite unir cuantos gráficos quieras, en la distribución que quieras. Sólo basta guardar cada uno de los gráficos en un objeto distinto, y luego con una sintaxis sencilla ordenarlos en el lienzo. A continuación algunos ejemplos:grafico_ggrepel + grafico_ggtextFigura 3. patchwork: izquierda y derecha.grafico_ggrepel / grafico_ggtextFigura 4. patchwork: arriba y abajo.grafico_ggrepel / (grafico_ggtext | grid::textGrob('Este es un texto muy importante'))Figura 5. patchwork: formas más complejas.4. gganimateUsualmente pensamos en los gráficos de ggplot2 como elementos estáticos, y le dejamos visualizaciones más interesantes a herramientas como plotly o d3.js. Sin embargo, muchas personas no saben que podemos generar animaciones y gifs a través del paquete gganimate, tal como si estuvieramos trabajando con facetas.La explicación de cómo funciona gganimate amerita su propia entrada de blog. Por ahora, para mostrar este paquete en todo su esplendor, te comparto un gráfico que hice para el desafío con la evolución de la pirámide poblacional en Colombia desde 1950.Figura 6. Animación de la pirámide poblacional en Colombia.El código con el que generé este gráfico lo puedes encontrar acá.ConclusiónEs hora de subir el nivel de los gráficos que haces con ggplot2. Te invito que integres estos paquetes en tu flujo de trabajo normal en ggplot2 y que explores sus funcionalidades. La documentación de los paquetes la podrás encontrar en los siguientes links: ggtext ggrepel patchwork gganimateRecuerda compartir este post si te pareció interesante y si tienes alguna pregunta que me quieras hacer, dejarla en los comentarios." }, { "title": "La guía para manipular archivos con shell", "url": "/posts/la-guia-para-manipular-archivos-con-shell/", "categories": "Terminal", "tags": "shell, bash, zsh, tutorial", "date": "2022-03-27 21:10:00 -0500", "snippet": "En tu camino de aprendizaje de ciencia de datos, seguro has visto artículos o tutoriales en los que se emplean comandos de texto para navegar a través de las carpetas de tu computador, crear o elim...", "content": "En tu camino de aprendizaje de ciencia de datos, seguro has visto artículos o tutoriales en los que se emplean comandos de texto para navegar a través de las carpetas de tu computador, crear o eliminar archivos, descargar archivos de internet, interactuar con git, entre otras.Al principio estos comandos pueden parecer muy complejos, pero en el post de hoy quiero compartir contigo una guía básica para su utilización y que puedas desbloquear el potencial de tu computador.¿Qué es el shell?Un shell o línea de comandos, es el programa en tu computador que te permite comunicarte a través de comandos con el sistema operativo. El shell se puede acceder a través de una interfaz gráfica que se denomina terminal.Dependiendo del sistema operativo vas a encontrar distitos tipos de shell: Para Linux y versiones de MacOS anteriores a Catalina, el shell por defecto es Bash. Para versiones de MacOS desde Catalina, el shell es Z Shell (o Zsh). Para Windows, el shell predeterminado es PowerShell. Windows Susbsystem for Linux te permite ejecutar de manera nativa comandos de bash en windows. Puedes encontrar más información sobre su instalación aqui.En este tutorial me voy a enfocar específicamente en algunos comandos básicos de Bash y Zsh, cuyo uso es muy parecido. Todos los comandos que se mencionan abajo se van a ejecutar desde la Terminal, por lo que deberías abrirla antes de empezar.Navegar entre carpetasAl igual que cuando trabajas normalmente en tu computador a través de el Explorador de arvhicos o Finder, en el shell puedes desplazarte entre carpetas, crear carpetas nuevas, crear archivos, entre otras. Vamos a ver los comandos para hacer lo anterior.Lo primero es preguntarle al sistema operativo en qué carpeta estamos actualmente. Esto lo podemos hacer ejecutando el comando pwd, o present working directory. la Terminal te va a devolver una ruta de archivo cuando ejecutas este comando, que por defecto será el directorio de Inicio. En mi caso, este es /Users/camilomartinez.Ahora sigue cambiar ese directorio de trabajo. Usando el comando cd seguido de una ruta de archivo, podrás moverte de carpeta en carpeta. Por ejemplo, estando en el directorio de inicio, si ejecutas el comando cd Downloads vas a pasar a tu carpeta de descargas.Una nota sobre las rutas de archivosEl ejemplo anterior es ilustrativo de lo que puedes hacer con los comandos, pero en la mayoría de los casos no te vas a encontrar con turas de archivo tan simples. Por lo anterior, hay algunas cosas clave que tienes que saber antes de continuar.Lo primero es que las rutas de archivo se definen separando los nombres de la carpeta con la barra o slash (/). La ruta de archivos que mencioné arriba es entonces la carpeta camilomartinez dentro de la carpeta Users. Estas rutas pueden ser tan largas o tan cortas como quieras, teniendo múltiples carpetas dentro de carpetas.Lo segundo es que existen dos símbolos especiales para hacer referencias relativas a carpetas. Cuando estamos escribiendo una ruta de archivo, . hace referencia al directorio actual en el que estamos trabajando y .. al directorio padre.A modo de ejemplo, supongamos que estoy en la ruta por defecto /Users/camilomartinez. Si hay un comando que me pide definir la ruta de archivo - como los que verás más adelante-, . hace referencia a la ruta /Users/camilomartinez y .. hará referencia a /Users, porque es la carpeta que contiene a /camilomartinez.Por último, arriba mencioné que existe un directorio por defecto. El caracter ~ te permitirá hacer una referencia a ese directorio sin importar donde te encuentres.Por ejemplo, supón que estás en la ruta /Users/camilomartinez/Downloads/mi_carpeta y quieres ir a la carpeta de documentos de tu directorio principal. En vez de escribir varias veces .. después del comando cd, basta con que escribas cd ~/Documents.Ver el contenido de una carpetaAhora que sabes navegar entre las carpetas de tu computador, el paso siguiente es ver el contenido de dichas carpetas. Para ello, ubicandote en la carpeta deseada, vas a ejecutar el comando ls -lh. La Terminal te devolverá una lista de carpetas y archivos con sus respectvos nombres y peso.Notarás que hay algo nuevo en este comando: las dos letras precedidas por un guión. Esto es algo que verás de manera recurrente en los comandos y son opciones adicionales para modificar su comportamiento. Estas se denominan banderas o flags.En este caso, la bandera l hace que la salida del comando sea en una lista y la bandera h a que los pesos de los archivos sean más fáciles de leer. Como te puedes dar cuenta, -lh no hace referencia a una sóla bandera sino a dos separadas. Sin embargo, el shell permite abreviar varias banderas usando un sólo guión como te lo mostré anteriormente. En estricto sentido, podrías escribir ls -l -h y el comando funcionaría igual.Crear carpetas y archivosAhora que sabes navegar entre las carpetas de tu computador, el paso siguiente es manipular el contenido de dichas carpetas.Para crear una nueva carpeta en la ubicación deseada, ejecutas el comando mkdir seguido el nombre de la carpeta. Por ejemplo mkdir mi_carpeta.También puedes crear un archivo usando el comando touch, seguido del nombre y extensión que quieras. Es decir, si quieres crear un archivo de texto plano, debes ejecutar el comando touch mi_archivo.txt. Intenta crear una carpeta y un archivo dentro, y luego usar el comando ls -lh para ver si tuviste éxito.Borrar carpetas y archivosPuedes hacer ambas operaciones usando el comando rm. Para el caso de los archivos, sólo tienes que ir a la ruta donde está el archivo y ejecutar el comando mencionado, seguido del nombre del archivo. Es decir, si quieres eliminar el archivo que creaste arriba, puedes escribir algo como rm mi_archivo.txt.Para las carpetas debes añadir la bandera -r, de lo contrario no la podrás eliminar. A modo de ejemplo, para eliminar la carpeta que creaste arriba tienes que ejecutar rm -r mi_carpeta. Ten cuidado con la ejecución de este comando. Si eliminas una carpeta se eliminará todo su contenido. Por esta razón, la Terminal te va a preguntar si de verdad quieres eliminar la carpeta antes de hacerlo.Conclusión¡Espero que te haya gustado este post! Con lo que viste, ya puedes navegar fácilmente en las carpetas de tu computador sin necesidad de usar la interfaz gráfica de tu sistema operativo.En las siguientes semanas voy a publicar una serie de entradas sobre cómo modificar los permisos de los archivos, crear tus propios scripts y modificar variables de entorno en shell.Te invito a compartir este post si te pareció útil y que sigas aprendiendo a trabajar con el shell." }, { "title": "Plantillas para proyectos de ciencia de datos", "url": "/posts/plantillas-para-proyectos-de-ciencia-de-datos/", "categories": "Cookiecutter", "tags": "cookicutter, plantilla, ciencia-datos, tutorial", "date": "2022-03-20 12:30:00 -0500", "snippet": "Al iniciar tu proyecto de ciencia de datos seguro te has enfrentado a numerosas decisiones como qué carpetas crear, dónde guardar las fuentes de información, cómo organizar scripts y notebooks, dón...", "content": "Al iniciar tu proyecto de ciencia de datos seguro te has enfrentado a numerosas decisiones como qué carpetas crear, dónde guardar las fuentes de información, cómo organizar scripts y notebooks, dónde guardar los resultados de tu análisis, etc.Hoy te quiero presentar Cookiecutter, una herramienta para el manejo de plantillas que te ayudará a organizar tu proyecto de ciencia de datos y a comenzar a trabajar en lo realmente importante en cuestión de minutos.CookiecutterCookiecutter es una herramienta que funciona en la línea de comandos de tu computador y que te permite crear proyectos basados en plantillas, llamadas cookiecutters.Esta herramienta es multiplataforma - funciona en Windows, MacOS y Linux - y no tiene una restricción sobre los lenguajes para los que puedes crear plantillas. Si bien no es necesario saber Python para usar cookiecutter, es algo útil cuando quieras diseñar tu propia plantilla y trabajar con hooks.InstalaciónPara poder trabajar con Cookicutter debes tener Python instalado en tu computador. Puedes hacerlo directamente desde su página oficial o usando Conda. Si no tienes mucha experiencia trabajando con Python, te sugiero hacerlo con Conda.Luego tienes que hacer un ajuste al path de tu computador, procedimiento que va a cambiar dependiendo del sistema operativo que uses. Te recomiendo seguir las instrucciones en la documentación de Cookiecutter.Una vez hecho lo anterior, dependiendo de la instalación que seguiste, en la línea de comandos de tu computador vas a ejecutar:# Si no usaste Condapip install cookiecutter# Si usaste Condaconda install -c conda-forge cookiecutterEscoge tu plantillaAhora que tienes instalado Cookiecutter, lo siguiente es escoger una plantilla que quieres replicar en tu computador. Github es un excelente lugar para buscar, dado que hay un gran número de repositorios con plantillas hechas por la comunidad en muchos lenguajes. Sólo pones en el buscador algo como cookiecutter template y el lenguaje de tu elección.Para crear tu primer proyecto con Cookiecutter te invito a trabajar con alguna de las dos plantillas que escribí para R y Python. Escoje alguna de ellas y copia la URL del repositorio en el portapapeles.Crea tu proyectoAbre la línea de comandos de tu computador - Command Shell en Windows o Terminal en MacOS y Linux - y ve a la carpeta en la que quieres crear tu proyecto. Una vez allí, ejecuta el siguiente comando:cookiecutter &lt;URL de Github&gt;Es decir, si quisiera usar la plantilla que escribí para Python escribiría:cookiecutter https://github.com/camartinezbu/cookiecutter-python-projectSi Cookiecutter quedó instalado correctamente, la línea de comandos te pedirá algunos datos con los que generar tu proyecto. Para la plantilla de Python estos son: project_name: El nombre del proyecto que vas a crear. project_slug: El apodo para tu proyecto. Por defecto incluye una versión en minúsculas separada por guión bajo del nombre del proyecto, pero lo puedes reemplazar por un apodo de tu elección. project_author_name: Tu nombre o el de la organización que elabora el proyecto. project_description: Una descripción breve del objetivo del proyecto. project_open_source_license: La elección de licencia que vas a usar en el proyecto. La plantilla incluye las opciones de no usar licencia, la licencia MIT y la licencia BSD-3-Clause. python_version: La versión de python para usar en el proyecto. Por defecto se incluye la versión 3.10. project_packages: Una selección de algunos paquetes básicos de ciencia de datos. Si seleccionas Basic se incluirán numpy, pandas, matplotlib y seaborn entre otros. Si seleccionas Scikit-learn o Tensorflow se instalará además el paquete corresponidnete. La plantilla de R te pedirá los mismos datos, excepto python_version y project_packages.Luego de introducir los datos anteriores, tu terminal debería verse similar a esta:Figura 1. Captura de pantalla de la Terminal al crear tu proyecto.Como resultado, tendrás una plantilla de proyecto con carpetas para: Datos y su documentación: data y references Cuadernos de Jupyter: notebooks Reportes: reports Salidas gráficas: figures El código para el proyecto, cargado como un paquete de python: srcAdicionalmente, la plantilla generará automáticamente: un archivo README.md con la información que diligenciaste en la terminal un archivo con la licencia escogida: LICENSE un archivo environment.yml para crear un ambiente de conda un repositorio de gitFigura 2. Captura de pantalla de la carpeta creada con la plantilla.¡Y listo! Ya puedes empezar a trabajar en tu proyecto de ciencia de datos.ConclusiónCon esta explicación breve ya debes poder usar Cookiecutter y crear una carpeta de proyecto en tu computador con base en una plantilla. Te invito a buscar más plantillas en Github y experimentar con ellas para encontrar la que más se ajuste a tu flujo de trabajo. En el siguiente post aprenderás cómo crear tus propias plantillas y personalizar sus funciones.Si te pareció útil te invito a compartir este artículo en tus redes sociales y a dejar tus comentarios al final de la página." }, { "title": "Condicionar la ejecución de comandos dentro de pipes", "url": "/posts/condicionar-la-ejecucion-de-comandos-dentro-de-pipes/", "categories": "R", "tags": "r, pipe, condicional, turorial", "date": "2022-03-06 10:30:00 -0500", "snippet": "Buena parte del tiempo que pasamos trabajando con el tidyverse lo hacemos usando el operador pipe (%&gt;%). Este operador nos permite fácilmente incluir la salida de una función como argumento de l...", "content": "Buena parte del tiempo que pasamos trabajando con el tidyverse lo hacemos usando el operador pipe (%&gt;%). Este operador nos permite fácilmente incluir la salida de una función como argumento de la siguiente, y de esta manera encadenar comandos para realizar modificaciones complejas a una base de datos con una gran legibilidad.Sin embargo, ¿qué sucede si quiero supeditar la ejecución de alguno de los comandos del pipe a una condición? Esto es lo que les voy a mostrar en el blog de hoy.Un repaso rápido de los pipesEl pipe viene del paquete magrittr, que se carga automáticamente cuando llamamos al tidyverse en nuestro código. Si ya has trabajado antes en análisis de datos con R, seguro el siguiente código es familiar:tabla_resumen &lt;- data %&gt;% group_by(columna1) %&gt;% summarise(total = sum(columna2)) %&gt;% arrange(desc(total)) %&gt;% head(10)Para un dataframe arbitrario, es claro ver que estoy agrupando por una columna llamada columna1, sumando para cada valor de esa columna los valores de columna2 y asignándolo a la columna total, ordenandola de mayor a menor y asignando las primeras 10 filas a un dataframe llamado tabla_resumen. Si no usaramos el pipe y creáramos objetos intermedios para cada operación mencionada, tendríamos que hacer algo del estilo:datos_agrupados &lt;- group_by(data, columna1)datos_resumidos &lt;- summarise(datos_agrupados, total = sum(columna2))datos_ordenados &lt;- arrange(datos_resumidos, desc(total))tabla_resumen &lt;- head(datos_ordenados, 10)Como puedes ver, la implementación a través del pipe es más ordenada y fácil de leer, y nos ahorra la necesidad de crear y almacenar objetos en memoria que no vamos a necesitar.¿Cómo entran los condicionales?Trabajar con las estructuras de control de if es relativamente sencillo en R base, usando la sintaxis:if (condicion) { #comandos}Adicionalmente, el uso de condiciones dentro de los pipes no es ajeno para el tidyverse. Funciones como case_when() permiten aplicar una serie de condiciones de manera abreviada para tareas como modificar una columna de la base de datos. Por ejemplo, si quieremos separar los valores de una columna con base en los cuartiles, podemos hacer algo del estilo:datos %&gt;% mutate(segmento = case_when( columna1 &lt;= quantile(columna1, .25) ~ 'segmento1', columna2 &gt; quantile(columna1, .25) &amp; columna2 &lt;= quantile(columna1, .5) ~ 'segmento2', columna2 &gt; quantile(columna1, .5) &amp; columna2 &lt;= quantile(columna1, .75) ~ 'segmento3', TRUE ~ 'segmento4' ))Ahora bien, qué pasa si queremos aplicar el condicional sobre la ejecución misma de alguno de los comandos dentro de un pipe. Lo primero que se viene a la cabeza es simplemente incluir la estructura de un if dentro del pipe ¿verdad? Sigamos el ejemplo de la base de datos arbitraria de antes. Supongamos que en vez de agrupar siempre, queremos definir una condición para decirle al pipe cuándo si y cuando no ejecutar esa línea de código. La idea de aplicar el if directamente sería algo como:tabla_resumen &lt;- data %&gt;% if (condicion == TRUE) { group_by(columna1) } %&gt;% summarise(total = sum(columna2)) %&gt;% arrange(desc(total)) %&gt;% head(10)Sin embargo, el paquete magrittr no sabe qué hacer con esta manera de escribir la instrucción y devolverá un error. En ese sentido, vamos a hacer tres cambios para que funcione y sea fácil de leer dentro del pipe.if…else de una líneaLo primero es ajustar la manera como está escrito el if...else. Si bien la manera en que usualmente se encuentra su sintaxis tiene varias líneas, también podemos escribirla en una sola línea. Los dos comandos siguientes funcionan exactamente igual:# Varias líneasif (condicion == TRUE) { print('La condición se cumple') } # Una líneaif(condicion == TRUE) print('La condición se cumple')Nota como el cambio entre los dos es que se ahorra el uso de unos corchetes. Sólo por el hecho de que la función print no está entre los primeros paréntesis, R entiende que esa es el comando a ejecutar en caso que la condición sea cierta y no parte de la condición.Lo anterior también aplica si tenemos un else:# Varias líneasif (condicion == TRUE) { print('La condición se cumple') } else { print('La condición no se cumple') }# Una líneaif(condicion == TRUE) print('La condición se cumple') else print('La condición no se cumple')En estricto sentido, este cambio no va a hacer que el if...else funcione diferente dentro del pipe. Sin embargo, en mi opinión escribirlo en una sóla línea ayudará a que se vea mejor en esta serie de comandos y facilitará su lectura.CorchetesLo siguiente es que magrittr necesita saber que ese if...else hace parte del pipe y lo puede encadenar a los demás comandos. Para ello, tenemos que encerrarlo en corchetes. Es decir, con los dos cambios vistos hasta el momento implican que la operación de agrupar según una condición se escribiría como:tabla_resumen &lt;- data %&gt;% { if (condicion == TRUE) group_by(columna1) } %&gt;% summarise(total = sum(columna2)) %&gt;% arrange(desc(total)) %&gt;% head(10)No obstante, esto también nos arrojará error. Si bien ya magrittr entiende que esto es un comando a encadenar, sigue sin saber qué encadenar con los siguientes comandos.Ajustes finalesEsto sucede por dos motivos. El primero es que no hemos definido qué sucede en ambos escenarios posibles: cuando la condición es cierta como cuando es falsa. El segundo es que internamente los pipes y las funciones del tidyverse tienen una manera de indicarle a las funciones dónde entran los resultados de las operaciones anteriores, que tenemos que llamar explícitamente dentro del if.Con respecto al primer motivo, deberíamos tener entonces un código del siguiente estilo:tabla_resumen &lt;- data %&gt;% { if (condicion == TRUE) 'salida1' else 'salida2' } %&gt;% summarise(total = sum(columna2)) %&gt;% arrange(desc(total)) %&gt;% head(10)El segundo motivo merece una explicación un poco más detallada. Al revisar la documentación de las funciones del tidyverse se puede ver que tienen un argumento que llamado .data. Este le indica a las funciones cuál es el dataframe sobre el que tienen que realizar la operación específica. Cuando no se está usando un pipe, tenemos que llamarlo de manera explícita como el primer argumento. Cuando usamos un pipe, éste se encarga de que el dataframe que venía antes sea ese .data y de esta manera encadenar los comandos. Por tal razón, estos dos elementos son exactamente iguales:# Sin pipehead(data, 10)# Con pipedata %&gt;% head(10)Como ahora tenemos dos posibilidades de qué hacer según la condición, para implementar el condicional dentro del pipe tenemos que definir explícitamente el nombre de lo que iría en ese .data con un placeholder. De esta manera, para ambas posibilidades del if...else, el pipe sabrá que hacer y podremos seguir con la ejecución del comando. Para ello, vamos a usar el caracter de punto ..Uniendo todo lo anterior, tenemos que la solución para implementar el ejemplo anterior sería algo como:tabla_resumen &lt;- data %&gt;% { if (condicion == TRUE) group_by(., columna1) else . } %&gt;% summarise(total = sum(columna2)) %&gt;% arrange(desc(total)) %&gt;% head(10)Lo que quiere decir esta nueva sintaxis es que si la condición es cierta, vamos a tomar el dataframe data -referenciada dentro de la función como . y lo vamos a agrupar de acuerdo con la columna1; y si la condición es falsa, vamos a devolver el mismo dataframe anterior, es decir data. Culquiera que sea la salida de este if...else, será un dataframe que se podrá inttroducir en la siguiente línea y ejecutar el resto de código con normalidad.ExtraComo ejercicio adicional, se podría incluir esta operación al interior de una función e incluir la condición como un argumento de dicha función:crear_tabla_resumen &lt;- function(dataframe, agrupar = TRUE) { output &lt;- dataframe %&gt;% { if (agrupar == TRUE) group_by(., columna1) else . } %&gt;% summarise(total = sum(columna2)) %&gt;% arrange(desc(total)) %&gt;% head(10) return output}# Agrupando por la columna 1tabla_resumen1 &lt;- crear_tabla_resumen(data, agrupar = TRUE)# Sin agrupar por la columna 1tabla_resumen2 &lt;- crear_tabla_resumen(data, agrupar = TRUE)Espero que te haya servido este tutorial y que puedas utilizar condicionales dentro de los pipes en R. Puedes leer más sobre su funcionamiento en este capítulo del líbro de R para Ciencia de Datos de Hadley Wickham." }, { "title": "Mapas de calor como calendarios en R", "url": "/posts/mapas-de-calor-como-calendarios-en-R/", "categories": "R", "tags": "r, calendar, heatmap, dataviz, tutorial", "date": "2021-05-19 11:30:00 -0500", "snippet": "Después de una pausa de algunas semanas vuelvo a escribir posts semanales en el blog. Para comenzar, quiero compartirles una visualización que me llamó mucho la atención al leer el libro Better Dat...", "content": "Después de una pausa de algunas semanas vuelvo a escribir posts semanales en el blog. Para comenzar, quiero compartirles una visualización que me llamó mucho la atención al leer el libro Better Data Visualizations de Jonathan Schwabish: Los Heatmap calendars, que acá voy a traducir -probablemente mal- como mapas de calor en forma de calendarios. Buena parte del insumo para este post viene de este tutorial de Viet Le.Paquetes necesariosPara este ejercicio voy a usar los siguientes paquetes: readxl para importar la base de datos que se encuentran en un archivo .xls, el tidyverse para la limpieza de los datos y la visualización con ggplot2, y lubridate para un par de operaciones puntuales con las fechas.Adicionalmente, usaré shadowtext para mejorar un poco la legibilidad del texto en el calendario al añadir sombras. Sin embargo, esto no es fundamental para hacer el calendar heatmap.Los datosVoy a usar un archivo de excel que contiene los registros de violencia intrafamiliar en Colombia durante 2019, disponibles para descarga en la página de Estadística Delictiva de la Policía Nacional.Esta base de datos contiene los siguientes campos de información: Departamento, Municipio, Código DIVIPOLA del municipio, Arma empleada, Fecha del registro, Sexo de la víctima, Grupo de edad de la víctima y un contador de cantidad de hechos. Para este ejercicio sólo nos interesa usar la fecha.ImportaciónLo primero que hay que hacer es cargar los paquetes que vamos a usar. Posteriormente, cargo la base de datos llamando de la función read_xlsx() del paquete readxl y la guardo en un objeto llamado vif.Adicionalmente, y por buenas prácticas, voy a definir la zona horaria de las fechas registradas en Bogotá con la función tz().library(tidyverse)library(readxl)library(lubridate)vif &lt;- read_xlsx(\"~/Downloads/violencia_intrafamiliar_2019_0.xlsx\", range = cell_limits(c(11, 1), c(113894, 8)))tz(vif$`FECHA HECHO`) &lt;- \"America/Bogota\"Acá vale la pena mencionar que por alguna razón escribir el rango de las celdas en el argumento range de read_xslx() en la forma A1:H113894 me generaba un error en la lectura. Una búsqueda rápida en internet me llevó a escribir el rango dentro de la función cell_limits(), lo que corrigió el problema.ProcesamientoAquí viene la parte mas importante. En esencia, lo que hacemos para hacer el mapa de calor en forma de calendario es colorear doce grillas de 7x4 -7 días y 4 semanas-, donde el color de cada celda obedece a un conteo de registros de violencia intrafamiliar.Sin embargo, como el resultado final debe parecer un calendario, necesitamos definir para cada registro en qué semana del mes y en qué día de la semana ocurrió. De lo contrario todos los meses empezarían el mismo día. Lunes o domingo, dependiendo del formato de calendario que se quiera usar.Para ello, vamos a ejecutar el siguiente bloque de código:historico_diario &lt;- vif %&gt;% transmute(FECHA = ymd(`FECHA HECHO`), CANTIDAD) %&gt;% group_by(FECHA) %&gt;% summarise(REGISTROS = sum(CANTIDAD)) %&gt;% ungroup() %&gt;% mutate(DIA = wday(FECHA, label = T, week_start = 1, locale = \"es_ES\")) %&gt;% mutate(MES = month(FECHA, label = T, locale = \"es_ES\")) %&gt;% mutate(SEMANA = isoweek(FECHA))historico_diario$SEMANA[historico_diario$MES==\"dic\" &amp; historico_diario$SEMANA == 1] = 53 historico_diario &lt;- historico_diario %&gt;% group_by(MES) %&gt;% mutate(SEMANA_MES = 1 + SEMANA - min(SEMANA))Vamos por partes. En el primer bloque de código creo una variable FECHA que contiene la fecha de la base de datos original en un formato que puede trabajar lubridate y selecciono la columna CANTIDAD. Luego hago una suma de los registros para cada uno de los días del año y calculo 3 variables nuevas: DIA: Una variable que contiene qué día de la semana (lunes, martes, miercoles, …) es cada fecha. Adicionalente, defino que el idioma para mostrar las etiquetas de los días sea español, usando el argumento locale. MES: Una variable que indica el mes del registro, con las etiquetas en español. SEMANA: Una variable que indica la semana del año a la que pertenece cada fecha,de 1 a 52, usando la función isoweek().Ahora bien, como puedes ver, hay una línea de código que modifica manualmente la variable semana. Esto sucede porque isoweek() define automáticamente la última semana del año como 1, si contiene algún día del año siguiente. Por esta razón, definimos que si el mes es diciembre y la semana del año es 1, la convierta en la semana 53.Finalmente, se crea una variable SEMANA_MES, de tal manera que se tenga a cuál semana de cada mes pertenece la fecha (1-4) y no la semana del año como en la variable SEMANA (1-52).El calendarioAhora si, después de todo lo anterior, podemos generar el calendario con el siguiente código:historico_diario %&gt;% ggplot(aes(x = DIA, y = -SEMANA_MES, fill = REGISTROS)) + geom_tile(colour = \"white\") + geom_text(aes(label = day(FECHA)), size = 2.5, color = \"white\") + theme(aspect.ratio = 1/2, legend.position = \"right\", axis.title.x = element_blank(), axis.title.y = element_blank(), axis.text.y = element_blank(), panel.grid = element_blank(), axis.ticks = element_blank(), panel.background = element_blank(), legend.title.align = 0.5, strip.background = element_blank(), strip.text = element_text(face = \"bold\", size = 15), panel.border = element_rect(colour = \"grey\", fill=NA, size=1), plot.title = element_text(hjust = 0.5, size = 18, face = \"bold\", margin = margin(0,0,0.5,0, unit = \"cm\"))) + scale_fill_viridis_c(name = \"Registros\", direction = -1, guide = guide_colourbar(title.position = \"top\", direction = \"vertical\")) + facet_wrap(~MES, nrow = 4, ncol = 3, scales = \"free\") + labs(title = \"Comportamiento de la violencia intrafamiliar \\nen Colombia durante 2019\", caption = \"Fuente: SIEDCO\")Si bien esto puede parecer muy complejo, la mayoría de instrucciones tienen que ver con que no salgan colores ni lineas en el fondo del gráfico, como es el comportamiento por defecto de ggplot2, y algunos ajustes del tamaño y posición del texto.Lo más importante está en que entiedas el llamado inicial de ggplot(), en el que se usan las variables de DIA y SEMANA_MES para construir la grilla que mencioné anteriormente, y se mapea el color a la variable de REGISTROS.Cuando corras ese código, vas a tener el siguiente resultado:Mapa de calor en forma de calendarioUn ajuste menor al textoComo te podrás dar cuenta, los números en color blanco no son fáciles de leer cuando el color del día es más claro. Esto podrías solucionarlo cambiando el color del texto o, como hice yo, usando el paquete shadowtext.Este paquete incluye una función para ggplot2 que funciona muy parecido a geom_text(), sólo que añade una sombra alrededor del texto: geom_shadowtext(). Reemplazando esta función en el código de arriba, ¡queda listo el mapa de calor con forma de calendario!Mapa de calor en forma de calendario con sombrasCon esta visualización podemos ver rápidamente que parece haber unos picos de registros de violencia intrafamiliar en fechas como navidad, año nuevo y el día de la madre, y que en términos generales parece que se registran más casos en los fines de semana. ¿Ves lo fácil que es extraer toda esta información con una sóla mirada?Espero que te haya gustado este post y que ahora puedas experimentar con mapas de calor en forma de calendario para datos de otros temas." }, { "title": "¿Qué son las expresiones regulares?", "url": "/posts/que-son-las-expresiones-regulares/", "categories": "Conceptos", "tags": "r, python, strings, regex", "date": "2021-02-28 11:30:00 -0500", "snippet": "Los strings son uno de los tipos de datos más comunes que te vas a encontrar en el análisis de datos. Ya sea porque te aparecen en un dataset listo, los consigues a través de ejercicios de webscrap...", "content": "Los strings son uno de los tipos de datos más comunes que te vas a encontrar en el análisis de datos. Ya sea porque te aparecen en un dataset listo, los consigues a través de ejercicios de webscraping o porque usas un texto completo para hacer procesamiento de lenguaje natural, aprender a trabajar con strings es una herramienta clave.Una de las herramientas más útiles para este tema son las expresiones regulares, comunmente abreviadas como regex por su nombre en inglés. En este post quiero darte una introducción a regex y que al finalizar tengas unas herramientas básicas para trabajar con ellas en tus análisis.¿Para qué expresiones regulares?Seguramente cuando trabajas un documento en word o estás navegando en una página web has usado la herramienta de busqueda. Al usar esta herramienta, el programa busca una correspondencia entre el término de búsqueda que pusiste y te señala las coincidencias que encontró en el documento. En algunos casos, incluso puedes señalar que no te importa si el texto está en mayusculas o minúsculas.Si bien esta herramienta es sumamente útil, se queda corta frente algunas operaciones más avanzadas. Esto pasa porque los textos suelen tener datos no estructurados y no es una opción realista escribir manualmente todas las posibles combinaciones de caracteres que cumplan una condición dada. Por ejemplo, encontrar todas las palabras con 4 o menos caracteres en nuestro texto.Para estos casos, las expresiones regulares te van a permitir navegar y encontrar patrones en los textos y describirlos a través de una sintaxis muy sencilla.Ahora bien, a modo de advertencia, si bien las expresiones regulares son simples en principio , pueden volverse rápidamente tan complicadas como lo quieras hacer. Un ejemplo de esto es esta regex para validar direcciones de correo electrónico.Antes de seguir, yo tampoco entiendo en su totalidad qué hace la expresión regular de arriba. Y rara vez trabajarás con una tan compleja. Al terminar de leer este post, vamos a entender esta expresión regular un poco más sencilla para detectar direcciones de correo electrónico válidas:\"^[a-zA-Z0-9_.+-]+@[a-zA-Z0-9-]+\\.[a-zA-Z0-9-.]+$\"¿Cómo entran en el flujo de trabajo?Muchos paquetes que trabajan con strings ofrecen funcionalidad para trabajar con expresiones regulares. Para el caso de R, los paquetes stringi o stringr del tidyverse permiten hacer busquedas y reemplazos basados en regex. En python, los módulos re y regex ofrecen esta funcionalidad.Para ambos casos, las expresiones regulares se escriben a su vez en strings, por lo que deben estar dentro de comillas.El objetivo de este post no es hacer una explicación de las funciones de estos paquetes, sino que entiendas en general su funcionamiento para utilizarlo en distintas situaciones y lenguajes de programación. En todo caso, al final encontrarás los enlaces a la documentación de estos paquetes.BúsquedasPara encontrar los patrones en el texto, las regex tienen una estructura muy estricta con algunos caracteres especiales. Vamos a ver cómo funcionan las búsquedas básicas y luego algunas funciones más avanzadas.a. Búsquedas básicasPara búsquedas muy básicas, las expresiones regulares funcionan de la misma manera que la herramienta de búsqueda en tu navegador o procesador de texto. Es decir, un regex de la forma test va a hacer match con todas las ocurrencias de este string en el texto.b. AnclasLas anclas son la primera herramienta clave para las regex. Usando los símbolos ^ y $ vamos a indicar si queremos que busque los caracteres dependiendo de si están al inicio o al final del string. Expresión Efecto ^El selecciona cualquier string que empiece con The fin$ selecciona cualquier string que termine con end ^El fin$ selecciona exactamente este string c. CuantificadoresAhora bien, hasta ahora tenemos que escribir exactamente el número de caracteres que queremos encontrar. Con los símbolos *, +, +, {} vamos a poder indicar si hay repetición de caracteres, como lo muestra la siguiente tabla: Expresión Efecto abc* selecciona un string que tenga ab seguido por cero o más c abc+ selecciona un string que tenga ab seguido por una o más c abc? selecciona un string que tenga ab seguido por cero o una c abc{2} selecciona un string que tenga ab seguido por exactamente dos c abc{2,} selecciona un string que tenga ab seguido por dos o más c abc{,4} selecciona un string que tenga ab seguido por hasta cuatro c abc{2,5} selecciona un string que tenga ab seguido por de 2 a 5 c Como puedes ver, estos simbolos sólo aplican para el caracter que está justo antes en la expresión regular. Para indicarle a la expresión regular que queremos que el cuantificador aplique para más caracteres, tenemos que usar paréntesis (). A modo de ejemplo: Expresión Efecto a(bc)* selecciona un string que tenga a seguido por cero o más copias de la secuencia bc a(bc){2,5} selecciona un string que tenga a seguido por de 2 a 5 copias de bc d. Operador oTal como si estuvieramos armando un condicional, podemos indicarle a la expresión regular si queremos que un string encuentre en una posición dada un caracter u otro.Para operaciones sencillas, usamos el caracter de línea vertical |, pero si tenemos que encadenar varios caracteres podemos usar los paréntesis cuadrados [] para abreviar. Adicionalmente, si escribimos al inicio de los paréntesis cuadrados el símbolo ^, es como si aplicaramos una negación. Expresión Efecto ab(c|d) selecciona tanto el string abc como abd ab[cdef] selecciona los strings abc, abd, abe y abf ab[^cdef] selecciona los strings que empiecen con ab seguidos por un caracter, excepto abc, abd, abe y abf e. Clases de caracteresAsí como los cuantificadores nos permiten especificar la búsqueda con respecto al número de caracteres, existe una sintaxis especial para buscar por el tipo de caracteres. Estos se describen a continuación: Expresión Efecto \\d selecciona un dígito \\w selecciona un caracter de palabra (caracter alfanumérico o guión bajo) \\s selecciona un caracter de espacio (incluye espacio, tab y nueva línea) . selecciona cualquier caracter Tal como cuando usabamos [] teníamos una negación, acá también existe. Para ello, escribimos estos mismos términos pero en mayúscula. Expresión Efecto \\D selecciona cualquier caracter excepto un dígito \\W selecciona cualqueir caracter excepto un caracter de palabra (caracter alfanumérico o guión bajo) \\S selecciona cualquier caracter excepto un caracter de espacio (incluye espacio, tab y nueva línea) Finalmente, vale la pena decir que hay algunas abreviaciones usando los paréntesis cuadrados que hacen match con ciertos grupos de caracteres más específicos: Expresión Efecto [a-z] selecciona una letra en minúcula [A-Z] selecciona una letra en mayúscula [0-9] selecciona un número de 0 a 9 “Escapando” caracteresComo te puedes dar cuenta, las regex usan una gran cantidad de símbolos para buscar ciertos patrones en el texto: ^ $ * + ? {} [] \\ .. Sin embargo, ¿qué sucede cuando queremos buscar específicamente estos caracteres en el texto?La respuesta es que tenemos que usar el \\ para escapar a la funcionalidad en expresiones regulares. Por ejemplo, si quiero buscar los puntos en un texto y no cualquier caracter, la expresión regular correspondiente es \\..Esto también implica que para efectos prácticos del uso de las clases de caracteres, no vamos a escribir \\d sino \\\\d dentro del string.El ejemplo de los correos electrónicosHabiendo visto lo anterior, volvamos a la expresión regular para la detección de correos electrónicos:\"^[a-zA-Z0-9_.+-]+@[a-zA-Z0-9-]+\\.[a-zA-Z0-9-.]+$\"Si bien antes parecía algo muy extraño, ya te puedes dar cuenta que en realidad es algo muy sencillo. Separemos la expresión regular en 3 partes para ver qué hace: ^[a-zA-Z0-9_.+-]+: Ubica los strings que empiecen por y tengan al menos una letra en mayúscula o minúscula, un número, un guión bajo, un punto, un más o un menos. @[a-zA-Z0-9-]+: Seguidos de un arroba y al menos una letra en mayúscula o minúscula, un dígito o un guión. \\.[a-zA-Z0-9-.]+$: Seguidos de un punto y que terminen en al menos una letra en mayúscula o minúscula, un dígito o un guión.Como te puedes dar cuenta, una dirección cualquiera como este_es_un_email_inventado@proveedor.net aparecería como resultado de la búsqueda al usar esta expresión regular.Al combinar todos los elementos descritos con anterioridad, puedes definir búsquedas muy poderosas que te van a facilitar el procesamiento de textos.Lecturas relacionadasYa conoces el funcionamiento básico de las expresiones regulares. Te invito a leer sobre la aplicación de las expresiones regulares en R y en python, así como algunos temas más avanzados como agrupaciones y los conceptos de lazy y greedy en los siguientes enlaces: El capítulo dedicado a strings del libro R for Data Science. La documentación stringr. La documentación de stringi. La documentación de re. La documentación de regex." }, { "title": "3 funciones de dplyr que no sabías que existían", "url": "/posts/3-funciones-de-dplyr-que-no-sabias-que-existian/", "categories": "R", "tags": "r, tidyverse, dplyr, funciones", "date": "2021-02-21 10:00:00 -0500", "snippet": "Dplyr es quizás uno de los paquetes más importantes del Tidyverse pues permite manipular dataframes fácilmente en R, a través de funciones como mutate(), select(), filter(), summarise(), arrange() ...", "content": "Dplyr es quizás uno de los paquetes más importantes del Tidyverse pues permite manipular dataframes fácilmente en R, a través de funciones como mutate(), select(), filter(), summarise(), arrange() y group_by().Cuando se usa con el operador pipe %&gt;%, el código hecho con este paquete es muy legible, por lo que hay menos riesgos de olvidar cuál fue el procedimiento que aplicamos en nuestra base de datos.Más allá de las funciones más comunes, hoy te quiero hablar de 3 funciones de dplyr que probablemente no conocías.1. TransmuteEn el trabajo del día a día, muchas veces me encuentro con la necesidad de sacar estadísticas de resumen de un dataframe dado, y lo que suele pasar es que llamo la función mutate() para computar alguna cifra en específico (por ejemplo, la tasa de homicidios por cien mil habitantes usando los registros de homicidios y la población) y luego tengo que usar select() para dejar únicamente las columnas que me interesan en una tabla final.Sin embargo, la función trasmute() puede ahorrarte estos pasos, pues permite crear nuevas variables en el dataframe y al tiempo borra las que no usaste.Veamos un ejemplo. Al instalar dplyr también descargas un dataframe llamado starwars que incluye la información de 87 personajes que aparecen entre en Episodio I y el Episodio VII. Entre las características de los personajes se incluyen la altura, el peso, el sexo, el planeta en que nacieron, etc.Supongamos que -por alguna razón- queremos calcular el Body Mass Index de todos los personajes. Si lo hicieramos usando mutate() y select() tendríamos que hacer algo de este estilo:starwars %&gt;% mutate(BMI = mass/(height/100)^2) %&gt;% select(name, height, mass, BMI)Ahora bien, usando transmute(), podemos abreviar esta operación de la siguiente manera:starwars %&gt;% transmute(name, height, mass, BMI = mass/(height/100)^2)Como puedes ver, sólo basta con llamar el nombre de una columna dentro de transmute() para que salga en la tabla final, y en la misma línea puedes crear nuevas variables, como si lo hicieras con la función mutate().Y si, el personaje con mayor BMI es Jabba, con un valor de 443.2. Coalesce¿Alguna vez te has encontrado con una tabla que quieras importar, en la que una columna esté separada en varias? Supón que tenemos una tabla con el resultado final de 5 estudiantes en una materia cualquiera. Sin embargo, en vez de anotar este resultado en una columna, la persona que hizo los registros los separó de la siguiente manera.Ejemplo resultados académicosPara este tipo de casos, la función coalesce() funciona perfectamente. Esta función encuentra el primer valor no vacío para cada posición y también permite juntar en una sola columna los valores separados como en el ejemplo anterior. Para este caso, primero vamos a cambiar un poco el contenido de las columnas, de tal manera que no nos quede sólo una columna de x, y luego crearemos la nueva columna usando esta función.resultados %&gt;% mutate(aprueba = str_replace(aprueba, \"x\", \"aprueba\")) %&gt;% mutate(reprueba = str_replace(reprueba, \"x\", \"reprueba\")) %&gt;% mutate(resultado = coalesce(aprueba, reprueba))Del código anterior nos quedará la siguiente tabla:Tabla de resultados académicos modificadaAquí pudimos haber usado la función transmute() para que no quedaran las columnas aprueba y reprueba.3. SliceUsualmente cuando tenemos que seleccionar algunas filas de un dataframe con dplyr, lo hacemos con la función filter(), que recibe como argumento un condicional. A modo de ejemplo, si queremos obtener los paises con un PIB per cápita superior a 3.000 USD en 2007 de la base de datos de gapminder, lo que haríamos es lo siguiente:library(gapminder) gapminder %&gt;% filter(year == 2007, gdpPercap &gt; 3000)Sin embargo, no en todos los casos queremos sacar parte de las filas de esta manera. Así como en R base podemos obtener un subconjunto de filas usando el operador de extracción [], dplyr contiene la función slice(). A modo de ejemplo, supongamos que queremos obtener el país con mayor población para cada continente en 1972. Esto lo podemos hacer de la siguiente manera:library(gapminder) gapminder %&gt;% filter(year == 1972) %&gt;% group_by(continent) %&gt;% arrange(continent, desc(pop)) %&gt;% slice(1)Dado que había ordenado la tabla en función al continente y a la población, aplicar la función slice() devuelve directamente el país con mayor población por cada continente:Paises más poblados por continente en 1972Como puedes ver, que además de permitir extraer filas con el número asociado a su posición, la función slice()se puede encadenar con el pipe %&gt;% y funciona muy bien con funciones como group_by(). En este caso, en vez de devolver sólo una fila, devolvió una fila por cada uno de los grupos que definimos. En este caso, los continentes.Bonus: Crucigrama de dplyrLa inspiración de este post me llegó por un crucigrama que descrubrí hace algunas semanas en el blog de Georgios Karamanis sobre funciones de dplyr. En mi primer intento logré llenar sólo 15 de las 34 funciones sin mirar en la documentación. ¡Te invito a que resuelvas este crucigrama e intentes superar mi resultado!" }, { "title": "¿Qué significa que los datos estén ordenados?", "url": "/posts/que-significa-que-los-datos-esten-ordenados/", "categories": "Conceptos", "tags": "tidy, data, estructurados, reglas", "date": "2021-02-14 14:00:00 -0500", "snippet": "Hay numerosas formas en las que podemos encontrar los datos para realizar nuestros análisis. No sólo me refiero a lo que tiene que ver con formatos - no siempre vamos a encontrar únicamente archivo...", "content": "Hay numerosas formas en las que podemos encontrar los datos para realizar nuestros análisis. No sólo me refiero a lo que tiene que ver con formatos - no siempre vamos a encontrar únicamente archivos .xlsx -, sino también a la organización misma de los datos en una tabla. Justo por esto, la limpieza y organización de los datos es una de las actividades más importantes en la Ciencia de Datos. Hoy les quiero hablar del concepto de Tidy data, cómo y cuándo aplicarlo en tu flujo de trabajo.Una claridadPara empezar, tenemos que partir de la base de que vamos a hablar de datos tabulares, es decir, que se distribuyen en filas y columnas. Puede parecer exagerado hacer esta claridad, después de todo estamos familiarizados con herramientas como Micosoft Excel o Google Sheets, que claramente cumplen estas características.Sin embargo, también existen diversas formas de almacenar datos que no necesariamente cumplen esta condición. Algunos ejemplos son los datos en formatos XML o JSON.¿Tidy data?Sin haberlo dicho explícitamente, seguro ya tienes una intuición de qué tipos de información se guardan en una base de datos. Lo que almacenamos es un conjunto de valores: pueden ser datos numericos o categóricos, que corresponden a una variable y una observacion.Una variable contiene todas las mediciones de un mismo atributo (por ejemplo la estatura de todas las personas que estudian en un salón de clases) y una observación contiene todos los atributos medidos para la misma unidad (edad, estatura, sexo, etc. para la misma persona).El Tidy data tiene que ver justamente con estos conceptos. Es un conjunto de principios cuyo propósito es estandarizar la manera en que se mapea la información contenida en las bases de datos con su estructura. Es decir, conseguir tablas en las que se pueda identificar fácilmente cuales son las observaciones, las variables y los valores, lo que a su vez facilitará su análisis en un lenguaje de programación.Los principios del Tidy dataDe acuerdo con el paper de Hadley Wickham una base de datos está ordenada (Tidy) o desordenada (Messy) dependiendo de si las filas, columnas y tablas corresponden con observaciones, variables y tipos. Sin entrar en detalles , esto tiene una explicación en las reglas de normalización para las bases de datos relacionales como SQL. Para efectos prácticos, en una base de datos ordenada: Cada variable forma una columna. Cada observación forma una fila. Cada unidad observacional es una tabla.Para los siguientes ejemplos, voy a usar la información del número de homicidios en 3 ciudades de Colombia, de acuerdo con la información descargada del Sistema de Información Estadístico, Delincuencial, Contravencional y Operativo de la Policía Nacional, junto con las proyecciones de población del DANE con base en el Censo de 2018.Tabla 1: Una tabla que cumple con los principios de Tidy DataComo puedes ver, la tabla anterior obedece a los principios del Tidy data. Cada observación - Bogotá, Medellín y Cali - está en una fila, cada variable - el año, la población, los homicidios y la tasa por 100.000 habitantes - está en su propia columna, y sólo tenemos una tabla porque sólo tenemos una unidad observacional - las ciudades -.Algunos ejemplos comunes de datos desordenadosSi las bases de datos ordenadas son las que cumplen con estos principios, las bases de datos desordenadas son las que incumplen al menos uno de ellos. A continuación vamos a ver los tipos más comunes de datos desordenados, que obedecen al incumplimiento de los principios 1 y 2 del Tidy data.Los nombres de las columnas son valores y no variablesEn este ejemplo, seleccioné únicamente la variable de Homicidios de la tabla. Como puedes ver, en vez de tener una columna con el año y una columna para homicidios, los nombres de las columnas contienen los años observados. De esta manera, hay 3 columnas que se refieren a la misma variable: Homicidios.Tabla 2: Los nombres de las columnas son valores y no variablesVarias variables están almacenadas en una columnaPara este caso, filtré la tabla para incluir únicamente las observaciones del año 2020. Al mirar la tabla se evidencia que las variables de Población, Homicidios y Tasa de homicidios se encuentran en una única columna llamdada Homicidios. Fïjate cómo se perjudica la legibilidad de la tabla al hacer este cambio.Tabla 1: Varias variables estan almacenadas en una columnaLas variables están almacenadas tanto en columnas como filasFinalmente, este ejemplo mezcla los dos casos anteriores. Por un lado, los valores de la variable año son los títulos de las columnas y por el otro, las variables de población, homicidios y tasa están en una misma columna.Tabla 4: Las variables están almacenadas tanto en columnas como en filas¿Siempre debo usar el tidy data?Es importante decir que esta no necesariamente es la manera “correcta” de almacenar los datos en una tabla. Probablemente las tablas que vayas a incluir en un reporte o en una presentación no cumplan con estos requisitos y esto no está mal per se. No en todas las ocasiones queremos que exista esta correspondencia entre los elementos y la estuctura de las tablas. Simplemente, los principios del Tidy data son útiles para efectos del análisis de datos y la programación.A modo de ejemplo, ya sabemos que la tabla 1 cumple con estos principios: las variables están en las columnas y las observaciones en las filas. Sin embargo, también es cierto que la tabla 2 es un poco más fácil de leer si quisieramos ver la evolución de los homicidios por ciudad en los últimos 3 años. Si bien el Tidy data es una herramienta importante para tu trabajo con datos, no necesariamete es una navaja suiza que sirva en todos los contextos.En todo caso, tener una manera estándar de almacenamiento de datos que tenga claras cuales son las observaciones, variables y valores, te puede ayudar a optimizar el flujo de trabajo y crear funciones para limpiar y procesar datos. No hay nada mejor que tener ya la función lista para el análisis de una base de datos que no habías trabajo antes.Bonus: ¿Y en Código?A modo de acompañamiento a este post, y para que conozcas algunas de las funciones útiles para organizar las bases de datos según lo visto anteriormente, escribí un script de R y un script de Python para pasar de la Tabla 1 a las tablas de los ejemplos de bases de datos desordenadas y viceversa. Puedes acceder a los scripts y al archivo .csv en el siguiente link.Espero que te haya inspirado conocer este concepto. Te invito a revisar el trabajo de Hadley Wickham, sobre el que me basé para escribir este post y que puedes encontrar en este link. Es una lectura corta pero amena, que te ayudará a profundizar sobre las aplicaciones del Tidy Data." }, { "title": "Hablemos de proyecciones", "url": "/posts/hablemos-de-proyecciones/", "categories": "Mapas", "tags": "mapas, r, leaflet, sf, ggplot, tmap, tutorial", "date": "2021-01-31 10:00:00 -0500", "snippet": "Ahora que conoces algunos paquetes para visualizar mapas, es importante que entiendas qué son las proyecciones, pues te van a servir para hacer análisis espacial más adelante.Un problema de geometr...", "content": "Ahora que conoces algunos paquetes para visualizar mapas, es importante que entiendas qué son las proyecciones, pues te van a servir para hacer análisis espacial más adelante.Un problema de geometríaPuede parecer obvio lo que voy a decir, pero la tierra es un objeto tridimensional que podemos aproximar matemáticamente a través de un geoide. Las ubicaciones en la superficie de este geoide se suelen describir con latidudes y longitudes, que representan las direcciones Norte/Sur y Este/Oeste, tomando como referencia la línea del Ecuador y el Meridiano de Greenwich.Ahora bien, no siempre tenemos a nuestra disposición un modelo tridimensional del globo para acercarnos lo más posible a la ubicación de un elemento en su superficie. En general usamos mapas para este propósito, pero eso introduce una dificutad y es que tenemos que transformar las ubicaciones de esta superficie a un plano. Este no es un asunto menor.En el Theorema Egregium, el matemático Carl Friederich Gauss probó que la superficie de una esfera no se puede representar en un plano sin distorsión. En la práctica, esto quiere decir que cuando hacemos un mapa en un plano, no necesariamente se van a conservar todas sus propiedades como el área, la forma, la dirección, la distancia, entre otras.Las proyeccionesNo hay una única forma de transformar las ubicaciones en la superficie de la tierra en un plano. De hecho, hay una gran cantidad de proyecciones distintas que buscan preservar alguno de los atributos descritos con anterioridad y que, según el internet, dicen cosas sobre nuestra personalidad.En vez de pegar imágenes de las proyecciones, que puedes encontrar fácilmente en linea, para este post quiero dibujar algunas proyecciones en R usando el paquete sf. Primero veamos las proyecciones y luego te enseñaré cómo hacer estos mapas.La lista de proyecciones que te voy a mostrar no es para nada exhaustiva y así como existen sistemas de coordenadas para el mundo, los hay para paises e incluso ciudades.MercatorLa proyección lleva el nombre del cartógrafo Gerardus Mercator y probablemente sea esta la que te imagines cuando pienses en un mapa del mundo. En la proyección Mercator se mantienen la dirección y la forma pero se distorsiona el tamaño a medida que se aleja del Ecuador.Proyección Mercator hecha en RMollweideEsta proyección se caracteriza por conservar el área en cualquier lugar del mapa. Fue creada por el matemático Karl Brandan Mollweide en 1805. Algunas de las aplicaciones de esta proyección son los mapas de la Radiación de fondo de microondas o de concentración de químicos en el mar.Proyección Mollweide hecha en RPlate CarréeEsta es una proyección equirrectangular, es decir, en la que los meridianos y paralelos se ubican como líneas con igual distancia entre si. Esto implica que no se conserva ni el área ni la forma, pero a pesar de esto, se suele utilizar para mapas temáticos.Proyección Plate Carrée hecha en RAitoffLa proyeccción de Aitoff conserva la dirección y la distancia de todos los puntos al centro del mapa, donde se cruza el meridiano de Greenwich y el Ecuador.Proyección Aitoff hecha en RWinkel tripelEsta proyección fue propuesta por el cartógrafo Oswald Winkel y tiene la particularidad de ser la media aritmética entre la proyección equirrectangular y la proyección de Aitoff.La proyección de Winkle busca minimizar tres tipos de distorsión (de ahí el tripel en su nombre): área, dirección y distancia, y es usada por la National Geographic Society.Proyección Winkel tripel hecha en RFlujo de trabajo en RPara los mapas anteriores usé un shapefile descargado del repositorio de información geográfica geoBoundaries, en el que puedes encontrar la información de la división administrativa de muchos países en varias resoluciones. En este caso, yo descargué la información del mundo sólo a nivel de paises, con baja resolución.Importando el mapaComo siempre, vamos a importar el shapefile usando la función st_read().library(sf)library(dplyr)library(rmapshaper)mapa_base &lt;- sf::st_read(\"geoBoundariesCGAZ_ADM0.shp\") %&gt;%rmapshaper::ms_simplify(sys = T, keep = 0.01) %&gt;%sf::st_as_sf()En el bloque de código anterior hago dos cosas adicionales. En primer lugar, del paquete dplyr uso el operador pipe para encadenar las salidas de cada linea de código con la entrada de la siguiente. El operador pipe es la secuencia de caracteres %&gt;%, y si has trabajado con el tidyverse te será familiar.En segundo lugar, uso la función ms_simplify del paquete rmapshaper para simplificar las geometrías y disminuir el tiempo que se demora en dibujar cada mapa. Dado que rmapshaper aún no tiene soporte completo para el paquete sf, internamente la función lo convierte en un objeto distinto, por lo que al final uso la función st_as_sf() para que el mapa vuelva a funcionar con sf.Funciones para trabajar con proyeccionesPara estos efectos, hay dos funciones clave. La primera es la función st_crs(), que permite extraer cuál es el sistema de coordenadas, y por extensión la proyección, del objeto con el que estamos trabajando.En general, los sistema de coordenadas que vas a encontrar siguen la nomencluatura “EPSG:XXXX”. La primera parte es por el European Petroleum Survey Group, o EPSG. Esta es una organización que mantiene una base de datos de sistemas de coordenadas geográficas. La segunda parte es el código en dicha base de datos con el que podrás acceder al sistema de coordenadas que necesites.Si corremos la siguiente línea de código,sf::st_crs(mapa_base)R nos debe devolver que este objeto tiene un ID EPSG de 4326. Puedes consultar más información sobre este y otros sistemas de coordenadas en este link.La otra función que nos va a ayudar es st_transform(). Con esta función, podremos convertir un mapa de un sistema de coordenadas geográficas a otro. Por ejemplo, si quiero convertir el mapa base al sistema EPSG:3116, que es el sistema oficial del Instituto Agustin Codazzi para Colombia, tendría que hacer lo siguiente:mapa_nuevo &lt;- sf::st_transform(mapa_base, crs = st_crs(\"EPSG:3116\")) Esta transformación en particular genera un error al intentar dibujar el mapa. Lo importante es que sepas cómo usar la función st_transform en caso que lo necesites.Código para dibujar los mapasCon las dos funciones anteriores, ya tenemos los elementos necesarios para transformar las proyecciones. Acá les dejo el código que usé para dibujar los mapas que aparecen más arriba en el post.library(dplyr)library(tmap)library(tmaptools)library(sf)mapa_base &lt;- sf::st_read('~/Downloads/World Map/geoBoundariesCGAZ_ADM0.shp') %&gt;% rmapshaper::ms_simplify(sys=T, keep = 0.01) %&gt;% st_as_sf()# Proyección de Mercatormapa_mercator &lt;- sf::st_transform(mapa_base, crs = st_crs(\"EPSG:3395\"))tm_shape(mapa_mercator, bbox = tmaptools::bb(mapa_mercator, ylim=c(-15496570.74, 18764656.23), xlim=c(-20026376.39, 20026376.39))) + tm_polygons() + tm_graticules()# Proyección de Molweidemapa_mollweide &lt;- sf::st_transform(mapa_base, crs = st_crs(\"ESRI:54009\"))tm_shape(mapa_mollweide) + tm_polygons() + tm_graticules()# Proyección Plate Carréemapa_plate_carree&lt;- sf::st_transform(mapa_base, crs = st_crs(\"EPSG:32662\"))tm_shape(mapa_plate_carree) + tm_polygons() + tm_graticules()# Proyección Aitoffmapa_aitoff &lt;- sf::st_transform(mapa_base, crs = st_crs(\"ESRI:54043\"))tm_shape(mapa_aitoff) + tm_polygons() + tm_graticules()# Proyección de Winkel tripelmapa_winkel &lt;- sf::st_transform(mapa_base, crs = st_crs(\"ESRI:54019\"))tm_shape(mapa_winkel) + tm_polygons() + tm_graticules()" }, { "title": "Estructuras de datos básicas en python", "url": "/posts/estructuras-de-datos-basicas-en-python/", "categories": "Python", "tags": "listas, tuplas, diccionarios, sets, python, arrays, tutorial", "date": "2021-01-24 10:45:00 -0500", "snippet": "Una de las primeras cosas que tienes que saber si quieres comenzar tu camino para programar en python son los diferentes tipos de estructuras de datos que tendrás a tu disposición. Cada una de ella...", "content": "Una de las primeras cosas que tienes que saber si quieres comenzar tu camino para programar en python son los diferentes tipos de estructuras de datos que tendrás a tu disposición. Cada una de ellas cuenta con características particulares, de tal manera que no hay una sóla que sea la solución a todos los problemas. Al finalizar este post tendrás las herramientas básicas para entender estas diferencias, crear estas estructuras y trabajar con ellas.ListasUna lista es una estructura de datos que puede contener elementos de distintos tipos: números, strings, booleanos, etc. aunque usualmente se usa para contener solamente uno. Es importante saber que las listas son mutables, es decir que se pueden modificar los elementos que estas contienen después de que la lista se creó y que los elementos tienen un índice numérico. Entraré en más detalle sobre esto cuando veamos cómo acceder a sus elementos.a. Crear una listaPara crear una lista en python, basta con escribir una secuencia de elementos separados por comas dentro de paréntesis cuadrados. A manera de ejemplo:# Crear una lista de un elementomi_lista1 = [4]# Crear una lsita de varios elementosmi_lista2 = ['Camilo', 'Martinez', 'Ciencia', 'Datos']b. Acceder a los elementos de una listaComo mencionaba con anterioridad, las listas están indexadas de manera numérica de conformidad con la posición de cada elemento de la lista. Esto es lo que permite acceder a los elementos de manera ordenada cuando estemos trabajando. Es muy importante decir que en Python se empieza contando desde 0. Es decir, el primer elemento de una lista tendrá un índice 0, el segundo tendrá un índice 1 y así sucesivamente.Supongamos que quiero acceder al string Ciencia en mi_lista2 del ejemplo anterior. Sabemos que Ciencia está en la tercera posición en la lista, lo que implica que el índice numérico que debemos usar es el 2. Entonces, para acceder a este elemento simplemente debemos escribir en python:mi_lista2[2]Estos paréntesis cuadrados que van después de una estructura de datos, se conocen como el Operador de subíndice (o Subscript operator en inglés). Hay muchas formas de jugar con este operador de subíndice; no necesariamente tendemos que extraer los elementos uno por uno. Por ejemplo, si queremos extraer Martínez y Ciencia, podemos usar un slice de la siguiente manera:mi_lista2[1:3]Te estarás preguntando, pero si Ciencia era el elemento 2 ¿por qué hay que poner 3 en el número de la derecha? Así como python cuenta desde 0 y no desde 1, cuando se hacen slices el número de la derecha es 1 + el índice que queremos. Supongamos que tenemos una lista con 20 elementos y quiero extraer el 6 al 15. Por la manera como está escrito python, tendríamos que escribir en el índice de la derecha 15+1, es decir, 16:mi_lista3[6:16]Por otro lado, recuerda que las listas son mutables, por lo que podemos modificar los elementos que están en la lista usando la misma forma de acceder a los elementos descrita anteriormente. Si por ejemplo quisiera modificar el Martínez por Rodríguez lo puedo hacer escribiendo:mi_lista_2[1] = 'Rodríguez'Encontrarás más información sobre esta forma de extraer y modificar elementos en este link.c. Métodos útiles de las listasNo voy en entrar en detalle en este post, pero es importante que sepas que Python es un lenguaje de programación orientado a objetos, un paradigma de la programación basado en el concepto de los objetos. Estos objetos pueden contener tanto datos como código y en términos generales tienen atributos, que son las características del objeto, y métodos, que son las acciones asociadas a éste. A continuación, algunos métodos útiles para trabajar con listas:# Añadir un elemento al final de una listami_lista.append('Nuevo elemento')# Eliminar todos los elementos de una listami_lista.clear()# Encontrar el índice de un elemento de la listami_lista.index('Elemento de la lista')# Reversar el orden de la listami_lista.reverse()# Ordenar la listami_lista.sort()# Contar cuántos elementos de la lista tienen un valor dadomi_lista.count('Valor para contar')TuplasLas tuplas son similares a las listas, en la medida que pueden almacenar elementos de distintos tipos y usan índices numéricos, pero a diferencia de ellas no son mutables.a. Crear una tuplaLa creación de una tupla es muy similar a la de una lista. En vez de usar paréntesis cuadrados usamos paréntesis normales. Ahora bien, para el caso de una tupla de un elemento, la creación es un poco distinta porque si sólo se encierra en paréntesis, python lo va a interpretar como un número, un string o un booleano común y corriente. Entonces, para crear una tupla escribimos:# Crear tuplas de un elementomi_tupla1 = (8,) # En este caso, siempre tenemos que escribir una coma después del único elemento# Crear tuplas de varios elementosmi_tupla2 = ('Manzanas', 'Peras', 'Uvas')b. Acceder a los elementos de una tuplaEsta operación sigue exáctamente las mismas reglas que el acceso a elementos en las listas. Para saber qué elemento queremos obtener tenemos que encontrar su posición en la tupla contando desde 0 y usar el operador de subíndice para elegirlo. Por ejemplo, si quiero seleccionar Manzanas de mi_tupla2, tengo que escribir:mi_tupla2[0]Como decía con anterioridad, las listas no son mutables, por lo que no las puedes modificar directamente. Es decir, un método como .append() no funcionaría en este caso. Sin embargo, si quieres crear una nueva tupla con elementos adicionales a la inicial puedes usar el operador +=. Por ejemplo, si quiero añadir fresas y duraznos a la mi_tupla2, puedo escribir:mi_tupla2 += ('Fresas', 'Duraznos')En estricto sentido, lo que hace esta línea de código no es modificar la tupla anterior, sino crear una nueva tupla que ahora contiene 5 elementos y ponerle el nombre de la tupla anterior. Puede parecer una diferencia muy pequeña pero cobrará importancia en la medida que trabajes más con éstas estructuras.c. Métodos útiles de las tuplasAl no ser mutables como las listas, las tuplas tienen menos métodos con los que puedes trabajar. Básicamente encontrarás dos métodos:# Encontrar el índice de un elemento de la listami_tupla.index('Elemeto de la tupla')# Contar cuántos elementos de la lista tienen un valor dadomi_tupla.count('Valor para contar')DiccionariosLos diccionarios son estructuras un poco distintas, que funcionan relacionando llaves (o keys) con valores de manera no ordenada (o más exactamente no tienen un índice numérico). En los diccionarios, las llaves deben ser inmutables (por ejemplo strings o tuplas) y deben ser únicas, aunque los diccionarios como tal si son mutables.a. Crear un diccionarioPara crear un diccionario vamos a usar corchetes para encerrar parejas de elementos separados por ‘:’ de la siguiente manera. El primer elemento va a ser la llave y el segundo elemento va a ser el valor.mi_diccionario = {'Bogotá': 11001 ,'Medellín': 05001, 'Cali': 76001}En este caso, creé un diccionario con el código DIVIPOLA de éstas tres ciudades, disponible aquí.b. Acceder a los elementos de un diccionarioEl operador de subíndice también funciona para los diccionarios, sólo que en este caso no vamos a incluir un índice numérico sino el nombre de la llave que queremos obtener. Por ejemplo, si quiero saber cuál es el código DIVIPOLA de Medellín, voy a escribir:mi_diccionario['Medellín']Ahora, supongamos que se me olvidó añadir a la ciudad de Bucaramanga y quisiera que estuviera incluida en mi diccionario. Para ello, hacemos una operación similar a la modificación de las listas que se describió con anterioridad:mi_diccionario['Bucaramanga'] = 68001Este mismo procedimiento lo podemos usar si nos equivocamos al introducir un valor en el diccionario (p.e. Si el código DIVIPOLA de Cali estuviera mal).Con esto, te debe quedar un poco más claro por qué los diccionarios se llaman así.c. Métodos útiles de los diccionariosAlgunos métodos que debes saber para trabajar con diccionarios son:# Eliminar todos los elementos de un diccionariomi_diccionario.clear()# Obtener una lista con todas llaves del diccionariomi_diccionario.keys()# Obtener una lista con todos los valores del diccionariomi_diccionario.values()# Obtener una lista de tuplas con cada llave y cada valormi_diccioanrio.items()# Eliminar una pareja de llave-valormi_diccionario.pop('Nombre de la llave')ConjuntosFinalmente, los conjuntos son colecciones no ordenadas de valores únicos y sólo pueden contener elementos inmutables como strings, números o tuplas.a. Crear un conjuntoPara crear un conjunto también usamos los corchetes, pero en vez de incluir parejas de llaves y valores separados por ‘:’, vamos a escribir los elementos a incluir de la siguiente manera:mi_conjunto1 = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10}Vale la pena decir, que también podemos crear conjuntos a partir de listas usando la función set(). Por ejemplo:mi_lista_para_conjunto = [1, 2, 2, 2, 3, 5, 7, 9]mi_conjunto2 = set(mi_lista_para_conjunto)En este caso vale la pena aclarar que si bien la lista tiene elementos repetidos, al crear el conjunto sólo apareceran los elementos una vez. Para este ejemplo, el conjunto estára compuesto por {1, 2, 3, 5, 7, 9}.b. Acceder a los elementos de un conjuntoEn vez de acceder a los elementos tal cual como lo hemos hablado para las estructuras de datos anteriores, al ser estructuras no ordenadas y de valores únicos, lo que podemos hacer con los conjuntos es verificar si un elemento está dentro del conjunto de la siguiente manera:1 in mi_conjunto111 not in mi_conjunto 1El resultado de la operación anterior será un booleano, es decir, un True o un False.c. Métodos útiles de los conjuntosTal como en la teoría de conjuntos que se ve en el colegio, las operaciones más interesantes de los conjuntos se dan cuando se interactúan varios conjuntos entre si. Aquí una lista de métodos útiles para conjuntos:# Añadir un elemento al conjuntomi_conjunto1.add('Elemento a añadir')# Eliminar un elemento del conjuntomi_conjunto.discard('Elemento a eliminar')mi_conjunto.remove('Elemento a eliminar')# Eliminar todos los elementos del conjuntomi_conjunto.clear()# Encontrar la unión de dos conjuntosmi_conjunto.union(otro_conjunto)# Encontrar la intersección de dos conjuntosmi_conjunto.intersection(otro_conjunto)# Encontrar si un conjunto contiene a otro conjuntomi_conjunto.issuperset(otro_conjunto)# Encontrar si un conjunto está contenido en otro conjuntomi_conjunto.issubset(otro_conjunto)# Encontrar si dos conjuntos son disjuntosmi_conjunto.isdisjoint(otro_conjunto)Espero que te haya servido esta guía para entender un poco mejor los diferentes tipos de estructuras de datos en python. Si quieres leer más del tema, también te recomiendo leer sobre los arrays de numpy, una estructura que trae algunas ventajas sobre las lsitas y que es la base de paquetes para ciencia de datos como pandas." }, { "title": "4 paquetes que debes conocer para hacer mapas en R", "url": "/posts/4-paquetes-que-debes-conocer-para-hacer-mapas-en-r/", "categories": "R", "tags": "mapas, r, leaflet, sf, ggplot, tmap, tutorial", "date": "2021-01-17 09:45:00 -0500", "snippet": "Así que decidiste aprender a usar R para trabajar con mapas. Esta guia te dará las herramientas básicas para que puedas hacerlo, incluyas visualizaciones de mapas en tu flujo de trabajo y te motive...", "content": "Así que decidiste aprender a usar R para trabajar con mapas. Esta guia te dará las herramientas básicas para que puedas hacerlo, incluyas visualizaciones de mapas en tu flujo de trabajo y te motives a hacer análisis espacial con este lenguaje.Código vs interfaces de usuarioAntes de comenzar, lo primero que tienes que saber es que para hacer mapas en R vas a tener que escribir código. No es código muy complejo si tienes una familiaridad básica con este lenguaje de programación, pero quizás al principio tiene una curva de aprendizaje más empinada que programas como ArcGIS (o su alternativa Open Source QGIS) en los que puedes interactuar a través de menús y botones con tu mouse.Sin embargo, si ya estás trabajando en un ambiente de R, si quieres automatizar la creación de muchos mapas con estructuras de control - los bucles con for-, o si te gustaría incluir fácilmente tu análisis en un dashboard de shiny, realizar mapas de esta forma puede ser una muy buena alternativa.¿Dónde consigo los mapas?Lo primero que te puedes estar preguntando es: ¿Pero y dónde encuentro los mapas para trabajar? Afortunadamente, en línea hay muchos repositorios de información con atributos espaciales. Aqui va una lista de enlaces que te pueden ser de utilidad para empezar.Para Colombia El Marco Geoestadístico Nacional del DANE contiene los polígonos del país, sus departamentos y municipios, con revisiones en 2005, 2012, 2017, 2018 y 2020. El portal de Datos Abiertos del IGAC tiene información de agrología, cartografía, geodesia, entre otros. El IDECA tiene una gran cantidad de información para Bogotá para un gran número de temáticas: Ordenamiento Territorial, Salud, Ambiente, Seguridad, entre otros. GeoMedellín aloja numerosos conjuntos de información geolocalizada para Medellín, también separados por temas.Para el resto del Mundo El GADM del Centro de Ciencias Espaciales de la Universidad de California, Davis tiene los shapefiles para todos los países y sus subdivisiones. Dependiendo el país que escojas habrá mayor o menor calidad de la información.Esta no es una lista exhaustiva de fuentes de información, así que si conoces otra fuente que creas que debe estar allí, compártemela para añadirla.El formato shapefileEl formato más común con el que te vas a encontrar es el shapefile. Este formato es desarollado por ESRI, la compañía que creó ArcGIS, y consiste en varios archivos con extensiones *.dbf, *.prj, *.sbn, *.sbx, *.shp, *.shx, entre otros.Para efectos prácticos, siempre que querramos importar o modificar el shapefile en R, vamos a referirnos únicamente al archivo *.shp y R se encargará del resto. Asímismo, es importante que no borres los archivos con las demás extensiones, dado que para que el shapefile funcione los necesitas a todos.Eventualmente, te puedes encontrar con otros formatos como el GeoPackage o geodatabase, pero la manera de trabajar con ellos en R es my similar a la del shapefile.1. Simple Features: sfSimple Features es un estándar para la representación de objetos espaciales de la vida real a través de geometrías -puntos, lineas, polígonos, etc. - en los sistemas de información geográfica. El paquete sf implementa este estándar en R y es con el que vamos a trabajar.En esta guía no vamos a cubrir cosas específicas como las funciones para personalizar los mapas, el sistema de coordenadas de los shapefiles u operaciones con y entre shapes. Por ahora solo vamos a importar un shape a R.Voy a usar el mapa de las localidades de la Bogotá disponible en la página del IDECA para hacer los siguiente ejemplos. Lo primero, y lo único, que vamos a hacer con sf será importar el shapefile. Para ello, vamos a correr el siguiente código:install.packages('sf') # Si no has instalado el paquete aúnlibrary(sf)mi_shape &lt;- sf::st_read('Loca.shp') # Debes modificar el contenido de st_read dependiendo de dónde tengas guardado el archivo.Si todo salio bien, deberías tener un objeto en r con clase sf, que contiene un mapa con las localidades de Bogotá.2. ggplot2La primera forma de visualizar este objeto es usando el paquete ggplot2 del tidyverse. Este paquete es una de las librerías más usadas para crear gráficos en R y tiene muchas opciones para ajustar cada detalle.Visualizar un mapa en ggplot es muy sencillo. Así como tienes funciones como geom_point() o geom_bar() para crear un gráfico de puntos o un gráfico de barras, el paquete sf contiene una función geom_sf() que se enlaza con ggplot2 y te permite visualizar el mapa.A modo de ejemplo, el resultado del siguiente código será:library(ggplot2)ggplot(data = mi_shape) + geom_sf()Mapa de las localidades de bogotá usando ggplot2De aqui en adelante, puedes jugar con las opciones de temas de ggplot2, para cambiar el color de fondo, la fuente, los ejes, entre muchas otras cosas. Por ejemplo, intenta añadir al final del código anterior + theme_void(). Casi cualquier configuración que funcionaría para un ggplot normal, funciona para un mapa hecho de esta forma.3. tmaptmap es un paquete diseñado específicamente para la creación de mapas temáticos con sf. tmap tiene una sintaxis muy parecida a la de ggplot y tiene la ventaja de que no tienes que lidiar con etiquetas de los ejes, color de fondo, etc. Ya está diseñado para sacar un mapa más limpio.Al ejecutar los siguientes comandos, tendrás como resultado:library(tmap)tm_shape(mi_shape) + tm_polygons()Mapa de las localidades de bogotá usando tmapUna vez estés familiarizado con este paquete, te recomiendo revisar el paquete tmaptools, que contiene algunas funciones útiles para trabajar con tmap.4. leafletFinalmente, el paquete leaflet ofrece una funcionalidad mucho más interesante: Interactividad. Con este paquete, puedes crear un mapa en el que podrás arrastrar, hacer zoom, definir que hace cuando haces clic o cuando pasas el mouse por encima de un polígono, entre muchas otras cosas.Lo mejor de todo, la sintaxis es parecida a los dos métodos anteriores, por lo que construir un mapa más complejo sigue siendo muy sencillo usando leaflet.Del siguiente código, resulta:library(leaflet)leaflet(data = mi_shape) %&gt;% addTiles() %&gt;% # Esta función añade el mapa de fondo, que peudes cambiar por muchas opciones addPolygons(weight = 0.5, label = ~LocNombre) Mapa de las localidades con leafletUna gran ventaja de trabajar con leaflet es que puedes integrar los mapas interactivos con tableros de visualización con shiny, conservando la interactividad con los usuarios. Si quieres saber cómo funciona shiny, revisa la introducción que hice en esta entrada de blog.Bonus: Haz el mapa de las calles de tu ciudadRecientemente encontré este tutorial de Christian Burkhart (@ChBurkhart) en el que describe cómo hacer un mapa usando osmdata y ggplot2. Te invito a que hagas este ejercicio, que no te tomará más de 5 minutos. Yo lo hice para Bogotá y no quedó tan mal.Con estos 4 paquetes, tienes lista una caja de herramientas para empezar a trabajar con mapas y al jugar con las opciones, podrás hacer visualizaciones profesionales y de manera muy fácil.Lecturas relacionadas Documentación de sf Documentación de tmap Documentación de leaflet para R" }, { "title": "¡Cuidado con los decimales!", "url": "/posts/cuidado-con-los-decimales/", "categories": "Conceptos", "tags": "float, numeros, python, integer, decimal, matematicas", "date": "2020-10-05 16:00:00 -0500", "snippet": "En general, usamos a los computadores para realizar cálculos que serían más complicados si los hacemos de manera manual. Tanto por la capacidad de los computadores de realizar muchas tareas repetit...", "content": "En general, usamos a los computadores para realizar cálculos que serían más complicados si los hacemos de manera manual. Tanto por la capacidad de los computadores de realizar muchas tareas repetitivas en menor tiempo, como por la menor posibilidad de introducir errores en las operaciones. Por ejemplo, oprimir el botón equivocado en la calculadora.Sin embargo, en lo que respecta a números decimales, la manera en cómo se procesan en muchos lenguajes de programación puede llevar a que algunas operaciones no se comporten como esperamos.El problemaPara explicar lo que no funciona, vamos a desarrollar un ejercicio muy sencillo. En una consola de python, realizar la siguiente operación1 + 2nos va a devolver 3. Esto es evidente, es una suma simple.Ahora bien, introduzcamos los números decimales al dividir la operación anterior entre 10. Es decir, sumemos0.1 + 0.2¿Debería dar 0.3 verdad? No exactamente. En realidad, python va a arrojar que la respuesta a esta suma es 0.30000000000000004. Claramente algo debe estar pasando tras bambalinas.Una particularidad para RSi bien este problema no se presenta en un entorno de R, no significa que no existan dificultades con los decimales. Si no me crees, intenta resolverceiling(31/60 * 60)Teniendo en cuenta que la función ceiling busca el número entero más pequeño que sea mayor o igual al argumento, esta expresión debería ser igual a 31 ¿cierto?FloatsLa manera como python y la mayoría de lenguajes de programación representan los números decimales es a través de los números de punto flotante, o de manera abreviada floats.Notación científicaEn el fondo, lo que hacen los floats es representar cualquier número en términos de notación científica. Es decir, separan el número en un significando y un exponente.El significando contiene los dígitos del número en cuestión y los almacena como un número con un sólo lugar en las unidades y cuántos decimales sean necesarios. A modo de ejemplo. Para el número 117, el significando sería 1.17.Por su parte, la parte del exponente indica en dónde va en realidad el punto decimal del número original. En otras palabras, por qué potencia de 10 tenemos que multiplicar el signficando para volver al número original. Para el mismo ejemplo, el exponente sería 2, pues al multiplicar 1.17 por 100, que es \\(10^2\\), volvemos a obtener 117.Esto también aplica para números negativos o números muy pequeños. Por ejemplo, si queremos representar -0.0005 en esta notación, tenemos que el significando es -5 y que el exponente es -4, pues al resolver \\(-5 * 10^{-4}\\) volvemos al número original.PrecisiónAhora bien, con todo esto no hay que perder de vista que los computadores almacenan los números en sistema binario. Es decir, en potencias de 2. Esto hace que la parte decimal de los números sea el resultado de sumar fracciones del estilo \\(1/2 + 1/4 + 1/8 + 1/16 + …\\).Dado lo anterior, es muy fácil representar 0.5 y de hecho, para este número no hay problema en la suma de fracciones. Sin embargo, no todos los números se pueden representar fácilmente de esta forma. Volviendo al caso inicial, no podemos escribir ni 0.1 ni 0.2 con una suma finita de potencias de 2. Entonces, lo que hace el computador es tratar de aproximar lo máximo posible al número deseado.Por esta razón, cuando insertamos en la consola de python0.1 + 0.2lo que hace el interpretador es procesar ambos números como floats y tratar de resolver la suma con la mejor aproximación posible teniendo en cuenta el sistema binario.Como resultado, lo que devuelve python es un valor muy cercano a 0.3, pero no exactamente igual.¿Qué hacer al respecto?DecimalsEn este caso, y en especial cuando tenemos que lidiar con cálculos de dinero y no nos podemos permitir estos pequeños errores, python incluye un tipo de número llamado Decimal en el módulo decimal.En el siguiente cuadro de código está la comparación de cómo escribimos un float y un número con esta nueva clase.from decimal import Decimal# 0.1 como float0.1#0.3 como DecimalDecimal('0.1')Al operar usando los Decimal vamos a tener que el problema inicial desaparece, y python va a resolver correctamente la operación de 0.1 + 0.2 y dará 0.3 cerrado.O… ¿nada?En la gran mayoría de casos, este tipo de problemas con los floats son demasiado pequeños como para que nos tengamos que preocupar. Es decir, ¿en realidad importa para todos nuestros cálculos una diferencia que está casi 20 ceros a la derecha del punto?Esto dependerá de la aplicación puntual que estemos desarrollando. Pero lo importante es estar consciente de que la mayoría de lenguajes de programación representan y almacenan los decimales de esta forma para saber en qué casos va a representar un problema y actuar de manera correspondiente.En este sentido, no es que hayamos vivido varias décadas con computadores que no saben sumar. Es que la forma en cómo se almacenan estos números no es tan intuitiva. Entonces, la próxima vez que vayas a hacer operaciones con decimales, presta mucha atención a cómo funcionan las floats y así te ahorrarás dolores de cabeza.Lecturas complementarias The floating point guide Floating point numbers - Computerphile Why doesn’t R think these numbers are equal?" }, { "title": "Una introducción a Jupyter", "url": "/posts/una-introduccion-a-jupyter/", "categories": "Jupyter", "tags": "jupyter, notebook, lab, reportes, python, r, tutorial", "date": "2020-09-28 16:15:00 -0500", "snippet": "Al trabajar en un proyecto que requiere gran cantidad de código, llenar el archivo con comentarios a través de numerales (#) puede no ser la mejor solución para entender qué estamos haciendo o para...", "content": "Al trabajar en un proyecto que requiere gran cantidad de código, llenar el archivo con comentarios a través de numerales (#) puede no ser la mejor solución para entender qué estamos haciendo o para compartirlo con otras personas. Después de todo, el archivo del código no tiene que ser el mismo de la documentación. Esto es justamente lo que buscan solucionar los cuadernos de Jupyter.Los Jupyter NotebooksSegún la documentación, los cuadernos de Jupyter son ambientes de computación interactiva que le permite al usuario hacer el reporte de alguna computación incluyendo código, gráficos, ecuaciones, imágenes, videos, entre otros. En cristiano, esto quiere decir que podemos explicar con detalle cada paso en el trabajo que estemos realizando y hacerlo ameno de leer para otras personas.Y ahora un dato coctelero. El Proyecto Jupyter (que incluye los cuadernos, JupyterHub y JupyterLab) fue creado por el Colombiano Fernando Perez a partir de sus desarrollos previos en IPython.Instalación e inicioLa manera más fácil de instalar Jupyter es a través de Anaconda, que es un programa de gestión de librerías para Python y R. Este incluye una instalación de Python y una serie de aplicaciones para el desarrollo de proyectos de ciencia de datos, incluyendo los cuadernos de Jupyter.Una vez realizada la instalación de Anaconda, podemos abrir un cuaderno de Jupyter de dos maneras. La primera es abrir la la aplicación llamada Anaconda Navigator y oprimir el botón de “Launch” que acompaña el logo de Jupyter Notebook o escribir en la terminal de comandos del computador:jupyter notebookEl flujo de trabajoAl ejecutar el código anterior, se debería abrir una pantalla en el navegador por defecto (en mi caso es Google Chrome), en el que se nos muestran las carpetas del directorio principal del computador. En la esquina superior derecha, se encuentra un botón que dice “New” que nos permitirá crear un nuevo cuaderno.Interfaz de JupyterEl trabajo en Jupyter se desarrolla a través de celdas. Así como en Excel las celdas pueden contener distintos tipos de datos, en Jupyter las celdas pueden estar en distintos modos: Código o Markdown. Mientras en el modo código se escribirán las instrucciones para que Jupyter ejecute, en el modo Markdown se incluirán el texto, el formato, las imágenes o el video de acompañamiento, como se muestra en la imagen anterior.Ahora bien, además del tipo de contenido que van a tener las celdas, hay dos modos del trabajo en el cuaderno. En el modo de edición, vamos a poder modificar el contenido de cada celda según lo que queramos hacer. En el modo de comandos, vamos a poder navegar entre las celdas, crear nuevas o eliminar existentes, y definir si las celdas van a ser de código o de Markdown.Entender los tipos de celdas y cómo navegar en el cuaderno son los únicos requerimientos para empezar a escribir cuadernos detallados y fáciles de seguir.Algunos atajos de tecladoSi bien la interfaz de Jupyter contiene botones para realizar la mayoría de acciones, después de trabajar con un par de cuadernos nos daremos cuenta que usar los botones no es la manera más rápida para trabajar. Estos son los atajos de teclado que uso más a menudo: Enter: Entrar al modo de edición en al celda seleccionada Esc: Salir del modo de edición y entrar al modo de comandos A: Insertar celda arriba (por la palabra Above) B: Insertar celda abajo (por la palabra Below) X: Cortar celda seleccionada C: Copiar celda seleccionada V: Pegar celdas copiadas D + D: Eliminar celda seleccionada Y: Cambiar la celda a modo de código M: Cambiar la celda a modo Markdown Ctrl + Enter o Cmd + Enter: Ejecutar el contenido de una celda de códigoJupyter LabJupyter Lab es la “nueva generación de interfaz de usuario basada en la web del Proyecto Jupyter”. A grandes rasgos, es una manera más refinada de interactuar con los cuadernos de Jupyter. Personalmente, prefiero trabajar con Jupyter Lab, dado que su interfaz es más intuitiva, permite interactuar más fácilmente con los demás archivos del computador y trabajar con varios cuadernos abiertos a la vez.La buena noticia es que al instalar Anaconda también instalamos Jupyter Lab. Similar a los cuadernos tradicionales, para abrir Jupyter Lab podemos usar el Navegador de Anaconda o simplemente escribiendo en la terminal de comandos:jupyter lab¿Y se puede utilizar con R?¡Claro que si! De hecho, el nombre Jupyter hace referencia a tres lenguajes de programación: Julia, Python y R. Y no sólo se puede trabajar con estos tres lenguajes. Una consulta a la documentación sobre los kernels de Jupyter muestra que también se encuentran soportados C#, JavaScript, Go, Ruby, PHP, entre otros.Para trabajar con algún lenguaje distinto a Python - que es la opción por defecto al instalar Anaconda - se debe instalar el kernel correspondiente. En el caso de R, tenemos que instalar el IRKernel desde la terminal de comandos. Este procedimiento no funciona desde la terminal de RStudio, es necesario primero abrir R desde la terminal de comandos del computador y ahí si seguir las instrucciones.Desde la terminal de R, vamos a escribir la siguiente línea de código para asegurarnos de que tenemos los paquetes necesarios instalados.install.packages(c('repr', 'IRdisplay', 'evaluate', 'crayon', 'pbdZMQ', 'devtools', 'uuid', 'digest'))Posteriormente, vamos a instalar el IRKernel como taldevtools::install_github('IRkernel/IRkernel')y luego la haremos visible a Jupyter al ejecutarIRkernel::installspec()Y ya está. La próxima vez que abramos Jupyter, podremos seleccionar la opción para trabajar cuadernos con R, a través de la instalación local con los paquetes que ya tengamos instalados.Jupyter Lab con R habilitadoEspero que este tutorial haya servido para motivarlos a usar los cuadernos de Jupyter por primera vez y a acercarse a Python a través de ellos. ¡Buena suerte escribiendo código!Lecturas complementarias Documentación sobre la edición individual de Anaconda. Tutorial sobre el formato Markdown Documentación sobre Jupyter Lab ¿Cómo usar Git en conjunto con Jupyter?" }, { "title": "¿Cómo hacer un dashboard en R?", "url": "/posts/como-hacer-un-dashboard-en-r/", "categories": "R", "tags": "tablero, dashboard, shiny, covid, dataviz, r, tutorial", "date": "2020-08-17 12:10:00 -0500", "snippet": "Los tableros o dashboards son herramientas muy útiles para extraer conclusiones de los datos, en ocasiones más convenientes que realizar muchas gráficas en excel para luego incluirlas en una presen...", "content": "Los tableros o dashboards son herramientas muy útiles para extraer conclusiones de los datos, en ocasiones más convenientes que realizar muchas gráficas en excel para luego incluirlas en una presentación de diapositivas. En este artículo se explicará cómo hacer un tablero básico de visualización en R y se compartirá el enlace para un ejemplo con base en la información de covid-19 del Instituto Nacional de Salud de Colombia.Los tableros de visualizaciónSeguramente has escuchado del furor alrededor de Tableau o PoweBI. Al revisar la documentación de sus servicios, la promesa de valor que ofrecen estas compañías está en “aprovechar el poder de los datos” o “eliminar la brecha entre los datos y la toma de decisiones”.Los tableros de visualización son formas eficientes de ver, y en algunos casos interactuar, con información relevante para un problema determinado. Piensa en la evolución de un reporte escrito que se realiza para el jefe de un proyecto, en la que la información más relevante se presenta en un sólo vistazo, es interactiva y, dependiendo de los datos disponibles, en tiempo real.Si bien las plataformas mencionadas son muy populares y robustas, no necesariamente son la mejor alternativa en todos los casos. Si quieres hacer una exploración de tus datos de manera rápida para hacer limpieza o preprocesamiento, o si quieres aprovechar alguna característica especial de una librería de tu lenguaje de programación preferido, existen alternativas que pueden hacer esta tarea más fácil y sin recurrir a servicios de terceros.Shiny y shinydashboardPara el caso de R, shiny es la librería por excelencia para realizar tableros de visualización con muy pocas líneas de código, desarrollada por RStudio. Por su parte, shinydashboard es un paquete complementario que ofrece un diseño con un encabezado, una barra lateral y un cuerpo para el tablero.La estructura más básica de un tablero de visualización hecho con shiny tiene la forma:library(shiny)library(shinydashboard)ui &lt;- dashboardPage( dashboardHeader(), dashboardSidebar(), dashboardBody())server &lt;- function(input, output) {}Como se puede ver, hay dos partes principales. La interfaz de usuario o ui es el objeto que define cómo será la visualización del tablero y los elementos que estarán allí incluidos. Por su parte, el servidor o server contiene todos los cálculos y operaciones necesarios para generar los elementos que se van a visualizar.Hay dos formas de escribir un tablero en scripts de R. La primera es generar un script que se llame app.R e incluir la interfaz y el servidor tal cual como aparecen en el ejemplo. La otra es definirlos en scripts separados y llamarlos ui.R y server.R. En mi opinión, la segunda forma es la más cómoda porque no es necesario desplazarse hacia arriba y hacia abajo cada vez que se añade algún elemento al tablero.Para lo que sigue de este artículo, el encabezado del tablero tendrá únicamente el título del tablero, la barra lateral estará deshabilitada y el cuerpo estará compuesto por únicamente una fila. Para mayor información sobre esta organización, la documentación de shinydashboard hace una explicación detallada. Dado lo anterior, la base de la aplicación sería la siguiente:ui &lt;- dashboardPage( dashboardHeader(title = \"Mi nuevo dashboard\"), dashboardSidebar(disable = T), dashboardBody( fluidRow(\"Única fila del tablero\") ))server &lt;- function(input, output) {}Render y OutputComo se mencionó, shiny usa una interacción entre los objetos del servidor y la interfaz de usuario. Para ello, los tableros de visualización utilizan dos familias de funciones para conectarlos: las funciones render_ en el servidor y _Output en la interfaz de usuario.Por ejemplo, digamos que se quiere imprimir el valor de una variable definida en el servidor. No se puede llamar simplemente a la variable como lo haríamos en un script ordinario. Por el contrario, se tiene que usar esta familia de funciones de la siguiente manera:ui &lt;- dashboardPage( dashboardHeader(title = \"Mi nuevo dashboard\"), dashboardSidebar(disable = T), dashboardBody( fluidRow( textOutput(outputId = \"mi_texto\") ) ))server &lt;- function(input, output) { x &lt;- 3 output$mi_texto &lt;- renderText({ paste(\"El valor de x es: \", x) })}El resultado del código anterior es un tablero así:Ejemplo 1. Render TextTal como lo muestra el ejemplo, el nombre que se le asigna al objeto en el servidor (el nombre que va después de output$) debe coincidir con el outputId de la función en la interfaz de usuario. De esta manera, shiny sabe cuál objeto ubicar en el tablero de visualización y en qué lugar.Cajas informativasDe esta misma manera podemos generar cajas informativas que contienen un valor numérico y una descripción de la información que está allí contenida. Siguiendo una forma muy similar, el siguiente códigoui &lt;- dashboardPage( dashboardHeader(title = \"Mi nuevo dashboard\"), dashboardSidebar(disable = T), dashboardBody( fluidRow( valueBoxOutput(outputId = \"mi_value_box\") ) ))server &lt;- function(input, output) { x &lt;- 42 output$mi_value_box &lt;- renderValueBox({ valueBox(x, subtitle = \"El sentido de la vida, el universo y todo lo demás\" ) })}genera el siguiente tableroEjemplo 2. Render Value BoxGráficosPara el caso de los gráficos, la sintaxis es muy similar. Se crea la gráfica desde el servidor usando renderPlot con una gráfica de ggplot2 y luego se carga en el tablero usando plotOutput.ui &lt;- dashboardPage( dashboardHeader(title = \"Mi nuevo dashboard\"), dashboardSidebar(disable = T), dashboardBody( fluidRow( plotOutput(outputId = \"mi_grafico\") ) ))server &lt;- function(input, output) { output$mi_grafico &lt;- renderPlot({ ggplot(mtcars, aes(x = mpg, y = hp)) + geom_point() })}Ejemplo 3. Render PlotTablero de covid-19Usando este flujo de trabajo sencillo de shiny y shinydashboard puedes empezar a experimentar con tus propios tableros de visualización sobre algún tema de tu interés. En mi caso, quise hacer un tablero básico de visualización sobre los datos de covid-19 en Colombia, publicados por el Instituto Nacional de Salud y que se pueden ver en el tablero de esa entidad.En este ejercicio usé una distribución de los elementos un poco más compleja, usando tab boxes y varias columnas por cada fila. Además, incluí cajas informativas, gráficos y un mapa interactivo con el paquete leaflet. Para ver y utilizar este tablero, puedes encontrar el código fuente y las instrucciones en el siguiente repositorio en Github.Lecturas complementarias Mastering Shiny Documentaciín de shiny Documentación de shinydashboard" } ]
